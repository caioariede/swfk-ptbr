% appendixb.tex
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 New Zealand License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.


\chapter{Funções Embutidas}\label{app:builtinfunctions}

O Python tem um número grande de funções embutidas --- funções que podem ser usadas sem precisar usar o \textbf{import} primeiro. Algumas das funções embutidas estão listadas abaixo.

\subsection*{abs}\index{functions!abs}

A função \textbf{abs}, retorna o valor absoluto de um número. Um valor absoluto, é um número que não é negativo. Então o valor absoluto de 10 é 10 e o valor absoluto de -20.5 é 20.5. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> print(abs(10))
10
>>> print(abs(-20.5))
20.5
\end{verbatim}
\end{listing}

\subsection*{bool}\index{functions!bool}

A função \textbf{bool} retorna tanto `True' quanto `False', baseado no valor passado por parâmetro. Para número, `0' retorna `False', enquanto para outros números retorna `True':

\begin{listing}
\begin{verbatim}
>>> print(bool(0))
False
>>> print(bool(1))
True
>>> print(bool(1123.23))
True
>>> print(bool(-500))
True
\end{verbatim}
\end{listing}

Para outros valores, `None` retorna `False' enquanto qualquer outra coisa retorna `True':

\begin{listing}
\begin{verbatim}
>>> print(bool(None))
False
>>> print(bool('a'))
True 
\end{verbatim}
\end{listing}

\subsection*{cmp}\index{functions!cmp}

A função \textbf{cmp} compara dois valores e retorna um número negativo se o primeiro valor for menor que o segundo; retorna 0 se o primeiro valor for igual ao segundo; e retorna um número positivo se o primeiro valor for maior que o segundo. Por exemplo, 1 é menor que 2:

\begin{listing}
\begin{verbatim}
>>> print(cmp(1,2))
-1
\end{verbatim}
\end{listing}

\noindent
E 2 é igual à 2:

\begin{listing}
\begin{verbatim}
>>> print(cmp(2,2))
0
\end{verbatim}
\end{listing}

\noindent
Mas 2 é maior que 1:

\begin{listing}
\begin{verbatim}
>>> print(cmp(2,1))
1
\end{verbatim}
\end{listing}

\noindent
Comparação não funciona apenas com números. Você pode usar outros valores, como strings:

\begin{listing}
\begin{verbatim}
>>> print(cmp('a','b'))
-1
>>> print(cmp('a','a'))
0
>>> print(cmp('b','a'))
1
\end{verbatim}
\end{listing}

\noindent
Mas fique atento com strings; o valor de retorno pode não ser exatamente o que você espera$\ldots$

\begin{listing}
\begin{verbatim}
>>> print(cmp('a','A'))
1
>>> print(cmp('A','a'))
-1
\end{verbatim}
\end{listing}

Um `a' minúsculo é realmente maior que o `A' maiúsculo. Claro$\ldots$

\begin{listing}
\begin{verbatim}
>>> print(cmp('aaa','aaaa'))
-1
>>> print(cmp('aaaa','aaa'))
1
\end{verbatim}
\end{listing}

\noindent
$\ldots$3 letras a's (aaa) é menor que 4 letras a's (aaaa).

\subsection*{dir}\index{functions!dir}

A função \textbf{dir} retorna uma lista de informações sobre um valor. Você pode usar a função \code{dir} em strings, números, funções, módulos, objetos, classes --- praticamente qualquer coisa. Em alguns valores, a informação pode não ser tão útil (ou talvez informações não tão importantes). Por exemplo, chamando a função \code{dir} no número `1' resulta em$\ldots$

\begin{listingignore}
\begin{verbatim}
>>> dir(1)
['__abs__', '__add__', '__and__', '__class__', '__cmp__', '__coerce__', '__delattr__', 
'__div__', '__divmod__', '__doc__', '__float__', '__floordiv__', '__getattribute__', 
'__getnewargs__', '__hash__', '__hex__', '__index__', '__init__', '__int__', '__invert__', 
'__long__', '__lshift__', '__mod__', '__mul__', '__neg__', '__new__', '__nonzero__', 
'__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', 
'__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', 
'__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__',
'__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__str__', '__sub__', '__truediv__',
'__xor__']
\end{verbatim}
\end{listingignore}

$\ldots$ um número razoável de funções especiais. Enquanto chamando o \code{dir} na string `a' resulta em...

\begin{listingignore}
\begin{verbatim}
>>> dir('a')
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__ge__', 
'__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__',
'__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', 
'__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', 
'__str__', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 
'find', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 
'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 
'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 
'swapcase', 'title', 'translate', 'upper', 'zfill']
\end{verbatim}
\end{listingignore}

Que mostra que existem funções como \code{capitalize} (deixa a primeira letra em maíusculo)$\ldots$

\begin{listing}
\begin{verbatim}
>>> print('aaaaa'.capitalize())
Aaaaa
\end{verbatim}
\end{listing}

$\ldots$\code{isalnum} (que retorna `True' se a string é alfanumérica --- contém somente letras), \code{isalpha} (que retorna `True' se a string contém somente letras) e assim por diante. A função `dir' pode ser útil quando você tem uma variável e quer saber rapidamente o que você pode fazer com ela.

\subsection*{eval}\index{functions!eval}

A função \textbf{eval} recebe uma string como parâmetro e a executa como se fosse uma expressão Python. É bem similar ao \textbf{exec}, que é um pouco diferente. Com o `exec' você cria um mini programa em Python na sua string, mas o `eval' permite a execução de expressões simples, como:

\begin{listing}
\begin{verbatim}
>>> eval('10*5')
50
\end{verbatim}
\end{listing}

\subsection*{file}\index{functions!file}

A função para abrir um arquivo e retornar um objeto `file', com funções que lhe permitem acessar informações no arquivo (o conteúdo do arquivo, seu tamanho, etc). Você pode encontrar mais informações sobre a função `file' e os objetos `file' no Capítulo~\ref{ch:ashortchapteraboutfiles}.

\subsection*{float}\index{functions!float}

A função \textbf{float} converte uma string ou número em um número de ponto flutuante. Um número de ponto flutuante é um número que tem casa decimal (também chamado de número real). Por exemplo, o número 10 é um `inteiro', mas 10.0, 10.1, 10.253 e por assim em diante, são todos `flutuantes'. Você pode converter uma string em `flutuante` usando:

\begin{listing}
\begin{verbatim}
>>> float('12')
12.0
\end{verbatim}
\end{listing}

\noindent
Você pode usar uma casa decimal na string, se quiser:

\begin{listing}
\begin{verbatim}
>>> float('123.456789')
123.456789
\end{verbatim}
\end{listing}

\noindent
Um número pode ser convertido em `float' usando:

\begin{listing}
\begin{verbatim}
>>> float(200)
200.0
\end{verbatim}
\end{listing}

\noindent
Claro que, convertendo um número de ponto flutuante, retorna apenas outro número de ponto flutuante:

\begin{listing}
\begin{verbatim}
>>> float(100.123)
100.123
\end{verbatim}
\end{listing}

\noindent
Chamando `float' sem argumentos, retorna 0.0.

\subsection*{int}\index{functions!int}

A função \textbf{int} converte uma string ou número em um número inteiro. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> int(123.456)
123
>>> int('123')
123
\end{verbatim}
\end{listing}

Essa função funciona um pouco diferente da função \textbf{float}. Se você tentar converter um número de ponto flutuante em uma string, você receberá uma mensagem de erro:

\begin{listing}
\begin{verbatim}
>>> int('123.456')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '123.456'
\end{verbatim}
\end{listing}

\noindent
Porém, se você chamar o `int' sem nenhum argumento, ele retornará 0.

\subsection*{len}\index{functions!len}

A função \textbf{len} retorna o tamanho de um objeto. No caso de uma string, retorna o número de caracteres na string:

\begin{listing}
\begin{verbatim}
>>> len('essa é uma string de teste')
27
\end{verbatim}
\end{listing}

\noindent
Para uma lista ou tupla, retorna o número de itens:

\begin{listing}
\begin{verbatim}
>>> minhalista = ['a', 'b', 'c', 'd']
>>> print(len(minhalista))
4
>>> minhalista = (1, 2, 3, 4, 5, 6)
>>> print(len(minhalista))
6
\end{verbatim}
\end{listing}

\noindent
Para um dicionário, retorna o número de itens:

\begin{listing}
\begin{verbatim}
>>> dct = {'a' : 100, 'b' : 200, 'c' : 300}
>>> print(len(dct))
3
\end{verbatim}
\end{listing}

\noindent
Você pode achar que a função `len' útil com laços, se quiser percorrer o número de elementos em uma lista. Você poderia fazer isso usando o seguinte código:

\begin{listing}
\begin{verbatim}
>>> minhalista = ['a', 'b', 'c', 'd']
>>> for item in minhalista:
...     print(item)
\end{verbatim}
\end{listing}

\noindent
Que imprimiria todos os itens da lista (a, b, c, d) --- mas e se você quisesse imprimir a posição no índice de cada item da lista? Neste caso, nós poderíamos encontrar o tamanho da lista e então percorrer a lista da seguinte forma:

\begin{listing}
\begin{verbatim}
>>> minhalista = ['a', 'b', 'c', 'd']
>>> tamanho = len(minhalista)
>>> for x in range(0, tamanho):
...     print('o item no indice %s é %s' % (x, minhalista[x]))
... 
o item no indice 0 é a
o item no indice 1 é b
o item no indice 2 é c
o item no indice 3 é d
\end{verbatim}
\end{listing}

\noindent
Nós armazenamos o tamanho da lista na variável `tamanho', e então usá-la na função \code{range} para criar o nosso laço.

\subsection*{max}\index{functions!max}

A função \textbf{max} retorna o maior item da lista, tupla ou até mesmo uma string. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> minhalista = [5, 4, 10, 30, 22]
>>> print(max(minhalista))
30
\end{verbatim}
\end{listing}

\noindent
Uma string onde os itens são separados por vírgula ou espaços também funcionará:

\begin{listing}
\begin{verbatim}
>>> s = 'a,b,d,h,g'
>>> print(max(s))
h
\end{verbatim}
\end{listing}

\noindent
E você não precisa usar listas, ou tuplas ou strings. Você também pode chamar a função `max' diretamente, com um número de argumentos:

\begin{listing}
\begin{verbatim}
>>> print(max(10, 300, 450, 50, 90))
450
\end{verbatim}
\end{listing}

\subsection*{min}\index{functions!min}

A função \textbf{min} funciona da mesma forma que a `max', exceto que ela retorna o menor item na lista/tupla/string:

\begin{listing}
\begin{verbatim}
>>> minhalista = [5, 4, 10, 30, 22]
>>> print(min(minhalista))
4
\end{verbatim}
\end{listing}

\subsection*{range}\index{functions!range}

A função \textbf{range} é usada principalmente em laços, quando você quer percorrer um código um número de vezes. Nós já vimos o `range' no Capítulo~\ref{ch:againandagain}, usando-o com dois argumentos, mas ele também pode ser usado com três argumentos. Aqui está outro exemplo do `range' usando dois argumentos:

\begin{listing}
\begin{verbatim}
>>> for x in range(0, 5):
...     print(x)
... 
0
1
2
3
4
\end{verbatim}
\end{listing}

\noindent
O que você não deve ter percebido, é que a função \code{range}, retorna apenas um objeto especial (chamado iterador), que o laço então percorre. Você pode converter o iterador em uma lista (curiosamente, usando a função \code{list}), então se você imprimir o retorno do valor quando chamar o `range', você verá os números que ele contém:

\begin{listing}
\begin{verbatim}
>>> print(list(range(0, 5)))
[0, 1, 2, 3, 4]
\end{verbatim}
\end{listing}

\noindent
Você terá uma lista de números que pode ser atribuida à uma variável e usada em qualquer lugar do programa:

\begin{listingignore}
\begin{verbatim}
>>> minha_lista_de_numeros = list(range(0, 30))
>>> print(minha_lista_de_numeros)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
\end{verbatim}
\end{listingignore}

\noindent
A função `range' também pode receber um terceiro argumento, chamado `step' (passo, em inglês), enquanto os dois primeiros parâmetros são `start' (início) e o `stop' (fim). Se o valor de `step' não for passado à função, ou em outras palavras, se você passar apenas os parâmetros início e fim, por padrão o número 1 será usado. Mas o que acontece quando nós passamos o número 2 como `step'? Você pode ver o resultado no seguinte exemplo:

\begin{listing}
\begin{verbatim}
>>> minha_lista_de_numeros = list(range(0, 30, 2))
>>> print(minha_lista_de_numeros)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]
\end{verbatim}
\end{listing}

\noindent
Cada número da lista, soma 2 a partir do último número. Nós podemos usar passos maiores:

\begin{listing}
\begin{verbatim}
>>> minhalista = list(range(0, 500, 50))
>>> print(minhalista)
[0, 50, 100, 150, 200, 250, 300, 350, 400, 450]
\end{verbatim}
\end{listing}

Isso cria uma lista de 0 à 500 (que não inclui o 500), somando os números em 50.

\subsection*{sum}\index{functions!sum}

The \textbf{sum} function adds up items in a list and returns the total number. For example:

\begin{listing}
\begin{verbatim}
>>> mylist = list(range(0, 500, 50))
>>> print(mylist)
[0, 50, 100, 150, 200, 250, 300, 350, 400, 450]

>>> print(sum(mylist))
2250
\end{verbatim}
\end{listing}

\newpage
