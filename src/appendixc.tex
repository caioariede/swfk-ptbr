% appendixc.tex
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 New Zealand License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.


\chapter{Alguns Módulos do Python}\label{app:afewpythonmodules}\index{modules}

O Python disponibiliza um grande número de módulos, fazendo todo tipo de coisa. Se você quiser ler mais sobre eles, você pode ir até a documentação do Python no seguinte endereço: \href{http://docs.python.org}{docs.python.org}, portanto, alguns dos módulos mais úteis estão dispostos abaixo. Um aviso caso você decida olhar na documentação do Python --- a lista de módulos é bem longe e alguns deles são um pouco complicados.

\subsection*{O módulo `random'}\index{modules!random}

Se você já jogou um jogo, onde você pergunta a alguém um número aleatório entre 1 a 100, você já sabe o que fazer com o módulo `random'. O módulo `random' contém um número de funções úteis para gerar$\ldots$ números aleatórios. É como pedir um número aleatório ao computador. O módulo `random' contém algumas funções, mas as mais importantes são \code{randint}\index{modules!random!randint}, \code{choice} e \code{shuffle}. A primeira função, \code{randint}, dá um número entre um número inicial e um final (em outras palavras, entre 1 e 100, 100 e 1000 ou 1000 e 5000, e por assim em diante). Por exemplo:

\begin{listingignore}
\begin{verbatim}
>>> import random
>>> print(random.randint(1, 100))
58
>>> print(random.randint(100, 1000))
861
>>> print(random.randint(1000, 5000))
3795
\end{verbatim}
\end{listingignore}

Nós podemos usar isso para criar um simples (e chato) jogo de adivinhação, usando um laço `while':

\begin{listingignore}
\begin{verbatim}
import random
import sys
num = random.randint(1, 100)
while True:
    print('Adivinhe um número entre 1 e 100')
    chk = sys.stdin.readline()
    i = int(chk)
    if i == num:
        print('Você acertou')
        break
    elif i < num:
        print('Tente um número maior')
    elif i > num:
        print('Tente um número menor')
\end{verbatim}
\end{listingignore}

Use o \code{choice}\index{modules!random!choice}, se você tiver uma lista e quiser pegar um número aleatório dela. Por exemplo:

\begin{listingignore}
\begin{verbatim}
>>> import random
>>> lista1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
>>> print(random.choice(lista1))
c
>>> lista2 = ['sorvete', 'panquecas', 'gelatina']
>>> print(random.choice(lista2))
gelatina
\end{verbatim}
\end{listingignore}

E finalmente, usar o \code{shuffle}\index{modules!random!shuffle} se quiser embaralhar uma lista (como se fossem cartas):

\begin{listingignore}
\begin{verbatim}
>>> import random
>>> lista1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
>>> lista2 = ['sorvete', 'panquecas', 'gelatina']
>>> random.shuffle(lista1)
>>> print(lista1)
['h', 'e', 'a', 'b', 'c', 'g', 'f', 'd']
>>> random.shuffle(lista2)
>>> print(lista2)
['panquecas', 'gelatina', 'sorvete']
\end{verbatim}
\end{listingignore}

\subsection*{O módulo `sys'}\index{modules!sys}

O módulo \code{sys} contém funções úteis de sistema. Essa é apenas uma forma de dizer que elas são bem importantes no Python. Algumas das funções mais úteis e valores disponíveis são no \code{sys}, são: \code{exit}, \code{stdin}, \code{stdout} e \code{version}.
\par
The \code{exit}\index{modules!sys!exit} function is another way of stopping the Python console. For example if you type:

\begin{listingignore}
\begin{verbatim}
>>> import sys
>>> sys.exit()
\end{verbatim}
\end{listingignore}

O terminal do Python irá parar. Dependendo do que você usar, se Windows, Mac ou Linux, um número diferente de coisas irá acontecer --- mas o resultado final é o terminal do Python parando de rodar.

\code{Stdin}\index{modules!sys!stdin} tem sido usado em alguns lugares neste livro (veja o Capítulo~\ref{ch:sortoflikerecycling}), pedindo à alguém que usa o programa para inserir alguns dados. Por exemplo:

\begin{listingignore}
\begin{verbatim}
>>> import sys
>>> minhavar = sys.stdin.readline()
este é um valor de teste
>>> print(minhavar)
este é um valor de teste
\end{verbatim}
\end{listingignore}

\code{Stdout}\index{modules!sys!stdout} é o oposto --- usado para escrever uma mensagem no terminal. De alguma forma, é o mesmo que o \code{print}, mas funciona mais como um arquivo, então em algumas vezes é mais útil usar o \code{stdout} do que o \code{print}:

\begin{listingignore}
\begin{verbatim}
>>> import sys
>>> l = sys.stdout.write('isso é um teste')
isso é um teste>>>
\end{verbatim}
\end{listingignore}

Notou onde o $>>>$ reapareceu? Não é um erro que está no final da mensagem. Isso ocorreu pois diferente do \code{print}, quando chamado o \code{write}, ele não adiciona automaticamente uma quebra de linha no final. Para fazer o mesmo com o \code{write}, nós podemos fazer o seguinte:

\begin{listingignore}
\begin{verbatim}
>>> import sys
>>> l = sys.stdout.write('isso é um teste\n')
isso é um teste
>>>
\end{verbatim}
\end{listingignore}

\noindent
(Repare que o \code{stdout.write} retorna o número de caracteres escritos --- tente \code{print(l)} para ver o resultado).

\noindent
{\textbackslash}n é o caracter de \emph{escape}\index{escape characters} para uma quebra de linha (o que sai quando você aperta o enter). Um caracter de escape, é um caracter especial que você usa em strings quando você não pode digitá-los diretamente. Por exemplo, se você quiser criar uma string contendo uma quebra de linha no meio, e tenta usar a tecla enter, você verá um erro:

\begin{listing}
\begin{verbatim}
>>> s = 'teste teste
  File "<stdin>", line 1
    s = 'teste teste
                   ^
SyntaxError: EOL while scanning single-quoted string
\end{verbatim}
\end{listing}

No lugar, você pode usar o caracter de escape de quebra de linha:
\begin{listing}
\begin{verbatim}
>>> s = 'teste teste\nteste'
\end{verbatim}
\end{listing}

\noindent
Finalmente, o \code{version}\index{modules!sys!version} é uma forma de exibir a versão do Python que você está usando:

\begin{listingignore}
\begin{verbatim}
>>> import sys
>>> print(sys.version)
2.5.1c1 (release25-maint, Apr 12 2007, 21:00:25) 
[GCC 4.1.2 (Ubuntu 4.1.2-0ubuntu4)]
\end{verbatim}
\end{listingignore}

\subsection*{O módulo `time'}\index{modules!time}

O módulo `time' do Python contém funções para exibir$\ldots$bem, horas, obviamente. Porém, se você tentar chamar as funções mais óbvias (\code{time})\index{modules!time!time}, o resultado não será bem aquilo que você está esperando:

\begin{listingignore}
\begin{verbatim}
>>> import time
>>> print(time.time())
1179918604.34
\end{verbatim}
\end{listingignore}

O número retornado pelo \code{time()} é o número de segundos desde o 1º de Janeiro de 1970 (às 00:00:00am para ser mais exato). Você pode não achar isso muito relevante, porém é, ocasionamente, tem os seus usos. Por exemplo, se você criar um programa e quiser saber quão rápido ele executa, você pode gravar o horário do início e o horário do fim, e então comparar os valores. Por exemplo, quanto tempo leva para imprimir todos os números de 0 a 100.000? Nós podemos criar facilmente uma função apra exibí-los:

\begin{listing}
\begin{verbatim}
>>> def muitos_numeros(max):
...     for x in range(0, max):
...         print(x)
\end{verbatim}
\end{listing}

\noindent
Então chamar a função:

\begin{listing}
\begin{verbatim}
>>> lots_of_numbers(100000)
\end{verbatim}
\end{listing}

\noindent
Mas se nós quisermos saber quanto tempo isso levará, nós podemos modificar a função e usar o módulo \code{time}:

\begin{listing}
\begin{verbatim}
>>> def muitos_numeros(max):
...     t1 = time.time()
...     for x in range(0, max):
...         print(x)
...     t2 = time.time()
...     print('levou %s segundos' % (t2-t1))
\end{verbatim}
\end{listing}

\noindent
Se chamarmos novamente:

\begin{listingignore}
\begin{verbatim}
>>> muitos_numeros(100000)
0
1
2
3
.
.
.
99997
99998
99999
levou 6.92557406425 segundos
\end{verbatim}
\end{listingignore}

\noindent
Como isso funciona? A primeira vez que chamamos a função \code{time()}, nós atribuimos o seu valor à variável \code{t1}. Nós então fazemos um laço e imprimimos todos os números. Novamente, nós chamamos a função \code{time()} e dessa vez atribuímos o seu valor à variavel \code{t2}. Desde que levou alguns segundos para terminar o laço, o valor de \code{t2} será maior que o \code{t1}, então se você subtrair o \code{t2} do \code{t1}, você terá o número de segundos que levou para imprimir todos os números.

Outras funções disponíveis no módulo `time', incluem: \code{asctime}, \code{ctime}, \code{localtime}, \code{sleep}, \code{strftime} e \code{strptime}.

A função \code{asctime}\index{modules!time!asctime} recebe uma data através de uma tupla (lembre-se: a tupla é uma lista de valores que não pode ser modificada) e a converte para uma forma legível. Você também pode chamá-la sem nenhum argumento e ela retornará a data e hora atual em um formato legível:

\begin{listingignore}
\begin{verbatim}
>>> import time
>>> print(time.asctime())
Sun May 27 20:11:12 2007
\end{verbatim}
\end{listingignore}

\noindent
Para chamá-la com um argumento, nós primeiro precisamos fazer uma tupla com os valores corretos de data e hora. Vamos atribuir a tupla à variável \code{t}:

\begin{listing}
\begin{verbatim}
>>> t = (2007, 5, 27, 10, 30, 48, 6, 0, 0)
\end{verbatim}
\end{listing}

\noindent
Os valores da sequência são ano, mês, dia, horas, minutos, segundos e dia da semana (0 para segunda-feira, 1 para terça-feira, e por assim em diante até domingo que é 6). Chamando \code{asctime} com a tupla acima, nós temos:

\begin{listing}
\begin{verbatim}
>>> import time
>>> t = (2007, 5, 27, 10, 30, 48, 6, 0, 0)
>>> print(time.asctime(t))
Sun May 27 10:30:48 2007
\end{verbatim}
\end{listing}

\noindent
Mas fique atento aos valores que você coloca na tupla. Alguns valores errados, podem ocasionar um resultado inesperado:

\begin{listing}
\begin{verbatim}
>>> import time
>>> t = (2007, 5, 27, 10, 30, 48, 0, 0, 0)
>>> print(time.asctime(t))
Mon May 27 10:30:48 2007
\end{verbatim}
\end{listing}

\noindent
Pois o valor do `dia da semana' foi especificado em 0 (ao invés de 6), o asctime agora pensa que dia 27 de Maio é uma segunda-feira, ao invés do que ela é --- um Domingo.

A função \code{ctime}\index{modules!time!ctime} é usada para converter números de segundos em uma forma legível. Por exemplo, nós podemos usar a função \code{time()}, explanada no começo da seção:

\begin{listingignore}
\begin{verbatim}
>>> import time
>>> t = time.time()
>>> print(t)
1180264952.57
>>> print(time.ctime(t))
Sun May 27 23:22:32 2007
\end{verbatim}
\end{listingignore}

\noindent
A função \code{localtime}\index{modules!time!localtime} retorna a data e hora atuais como uma tupla, na mesma sequência de valores que usamos:

\begin{listingignore}
\begin{verbatim}
>>> import time
>>> print(time.localtime())
(2007, 5, 27, 23, 25, 47, 6, 147, 0)
\end{verbatim}
\end{listingignore}

\noindent
Esse valor, nós também podemos passar para a função \code{asctime}:

\begin{listingignore}
\begin{verbatim}
>>> import time
>>> t = time.localtime()
>>> print(time.asctime(t))
Sun May 27 23:27:22 2007
\end{verbatim}
\end{listingignore}

\noindent
The function \code{sleep}\index{modules!time!sleep} is quite useful when you want to delay your program for a certain period of time.  For example, if you wanted to print out one number every second, the following loop wouldn't be very successful:

\begin{listing}
\begin{verbatim}
>>> for x in range(1, 61):
...     print(x)
...
1
2
3
4
\end{verbatim}
\end{listing}

It would instantly print out all the numbers from 1 to 60. However if you tell Python to go to sleep for a second between each print statement:

\begin{listing}
\begin{verbatim}
>>> for x in range(1, 61):
...     print(x)
...     time.sleep(1)
...
\end{verbatim}
\end{listing}

\noindent
There will be a short (1 second) delay between the display of each number. Telling a computer to sleep might not seem all that useful, but there are times when it can be.  Think about your alarm clock that wakes you up in the morning.  When you hit the sleep button, it stops buzzing for a few minutes, giving you an extra few moments of sleep (at least until someone calls you for breakfast).  The \code{sleep} function is just as useful in certain situations.

The function \code{strftime}\index{modules!time!strftime} is used to change the way a date and time value is displayed, and \code{strptime} is used to take a string and convert it into a date/time tuple. Let's look at strftime first.  Just before we saw how to change a tuple into a string using \code{asctime}:

\begin{listing}
\begin{verbatim}
>>> t = (2007, 5, 27, 10, 30, 48, 6, 0, 0)
>>> print(time.asctime(t))
Sun May 27 10:30:48 2007
\end{verbatim}
\end{listing}

\noindent
That works fine for most situations, but what if you don't like the way that string is displayed---what if you only want to display the date and not the time?  We can do that with \code{strftime}:

\begin{listing}
\begin{verbatim}
>>> print(time.strftime('%d %b %Y', t))
27 May 2007
\end{verbatim}
\end{listing}

As you can see, \code{strftime} takes 2 arguments:  the first is a date/time format (which describes how the date/time should be displayed), and the second is the tuple containing the time values.  The format, \%d \%b \%Y is another way of saying: `show the day, the month and then the year'.  We could also display the month as a number, for example:

\begin{listing}
\begin{verbatim}
>>> print(time.strftime('%d/%m/%Y', t))
27/05/2007
\end{verbatim}
\end{listing}

This format is a way of saying, `display the day, then a forward-slash, then display the month as a number, then a forward-slash, then display the year'.  There are a number of different values you can use in a format\index{date/time formats}:

\begin{center}
\begin{tabular}{|l|p{12cm}|}
\hline
\%a & a shortened version of a week day (for example, Mon, Tues, Wed, Thurs, Fri, Sat, and Sun) \\
\hline
\%A & the full weekday name (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday) \\
\hline
\%b & a shortened version of a month name (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct , Nov, Dec) \\
\hline
\%B & the full version of a month name (January, February, March, April, May, and so on) \\
\hline
\%c & the full date and time, in the same format the asctime uses \\
\hline
\%d & the day of the month as a number (from 01 to 31) \\
\hline
\%H & the hour of the day, in 24 hour format (from 00 to 23) \\
\hline
\%I & the hour of the day, in 12 hour format (from 01 to 12) \\
\hline
\%j & the day of the year as a number (from 001 to 366) \\
\hline
\%m & the month as a number (from 01 to 12) \\
\hline
\%M & the minute as a number (from 00 to 59) \\
\hline
\%p & morning or afternoon as either AM or PM \\
\hline
\%S & the seconds as a number \\
\hline
\%U & the week number of the year as a number (from 00 to 53) \\
\hline
\%w & the day of the week as a number.  Sunday is 0, Monday is 1, up to Saturday, which is 6 \\
\hline
\%x & a simple date format (usually month/day/year---for example, 03/25/07) \\
\hline
\%X & a simple time format (usually hour:minutes:seconds---for example 10:30:53) \\
\hline
\%y & the year in 2 digits (for example, 2007 would be 07) \\
\hline
\%Y & the year in 4 digits (e.g. 2007) \\
\hline
\end{tabular}
\end{center}

The function \code{strptime}\index{modules!time!strptime} is almost the reverse of \code{strftime}---it takes a string and converts it into a tuple containing the date and time values. It also takes the same values in the format string. An example of using this function is:

\begin{listingignore}
\begin{verbatim}
>>> import time
>>> t = time.strptime('05 Jun 2007', '%d %b %Y')
>>> print(t)
(2007, 6, 5, 0, 0, 0, 1, 156, -1)
\end{verbatim}
\end{listingignore}

\noindent
If the date in our string is day/month/year (for example, 01/02/2007), we might use:

\begin{listingignore}
\begin{verbatim}
>>> import time
>>> t = time.strptime('01/02/2007', '%d/%m/%Y')
>>> print(t)
(2007, 2, 1, 0, 0, 0, 3, 32, -1)
\end{verbatim}
\end{listingignore}

\noindent
Or if the date is month/day/year, we might use:

\begin{listingignore}
\begin{verbatim}
>>> import time
>>> t = time.strptime('03/05/2007', '%m/%d/%Y')
>>> print(t)
(2007, 3, 5, 0, 0, 0, 0, 64, -1)
\end{verbatim}
\end{listingignore}

\noindent
We can combine the 2 functions to convert a string in one format to another. Let's do it in a function:

\begin{listing}
\begin{verbatim}
>>> import time
>>> def convert_date(datestring, format1, format2):
...     t = time.strptime(datestring, format1)
...     return time.strftime(format2, t)
...
\end{verbatim}
\end{listing}

\noindent
We can use this function by passing in the date string, the format of that string, and then the format that we want the returned date in:

\begin{listing}
\begin{verbatim}
>>> print(convert_date('03/05/2007', '%m/%d/%Y', '%d %B %Y'))
05 March 2007
\end{verbatim}
\end{listing}

\newpage
