% ch5.tex
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 New Zealand License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.


\chapter{De novo e de novo}\label{ch:againandagain}

Não existe coisa pior do que ter que fazer a mesma coisa mais e mais vezes. Existe um motivo para que seus pais peçam para você contar ovelhas para tentar dormir e isso não tem nada a ver com um maravilhoso sono --- induzindo poderes de mamíferos fofinhos. Isso tem a ver com o fato de que contar infinitamente, a mesma coisa, é chato e a sua mente se desligará mais fácil para dormir, se não estiver focando em algo interessante.
\par
Além disso, especialmente os programadores não gostam de ser repetitivos. Isso os coloca para dormir de certa forma. Que é uma boa razão para que todas as linguagens de programação tenham o que é chamado de \textbf{laço-for}\index{for-loop}. Por exemplo, para imprimir `olá', 5 vezes em Python, você poderia fazer o seguinte:

\begin{listing}
\begin{verbatim}
>>> print("Olá")
Olá
>>> print("Olá")
Olá
>>> print("Olá")
Olá
>>> print("Olá")
Olá
>>> print("Olá")
Olá
\end{verbatim}
\end{listing}

Que é$\ldots$ bastante entediante.

Ou você poderia usar o `laço-for' (observe: existe 4 espaços na segunda linha, antes do comando `print' --- Eu os substituí por @ para que nós o pudessemos ver):

\begin{listingignore}
\begin{verbatim}
>>> for x in range(0, 5):
... @@@@print('Olá')
... 
Olá
Olá
Olá
Olá
Olá
\end{verbatim}
\end{listingignore}

\code{range}\index{functions!range} é uma função e uma forma rápida e fácil de criar uma lista contendo uma sequência de números entre um `início' e um `fim'. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> print(list(range(10, 20)))
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
\end{verbatim}
\end{listing}

Então, no caso do `laço-for', o código `\code{for x in range(0, 5)}' está dizendo ao Python para criar uma lista de números (0, 1, 2, 3, 4) e então para cada número, armazenar seu valor na variável \code{x}. Nós podemos então usar o \code{x} no nosso comando `print', se quisermos:

\begin{listing}
\begin{verbatim}
>>> for x in range(0, 5):
...     print('Olá %s' % x)
Olá 0
Olá 1
Olá 2
Olá 3
Olá 4
\end{verbatim}
\end{listing}

Se nos livrarmos do `laço-for' novamente, nós teríamos que fazer algo assim:

\begin{listing}
\begin{verbatim}
x = 0
print('Olá %s' % x)
x = 1
print('Olá %s' % x)
x = 2
print('Olá %s' % x)
x = 3
print('Olá %s' % x)
x = 4
print('Olá %s' % x)
\end{verbatim}
\end{listing}

Então o laço nos fez economizar, escrevendo 8 linhas a menos de código. Isso é extremamente útil, visto que um programador médio é mais preguiçoso que um hipopotamo no calor, quando o assunto é digitar. Bons programadores odeiam fazer coisas mais de uma vez, então o `laço-for' é um dos comandos mais úteis em uma linguagem de programação.

\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{AVISO!!!}

Se você esteve tentando os exemplos conforme foi lendo, você pode ter recebido uma mensagem de erro quando digitou o código para aquele `laço-for'. Se recebeu, foi algo assim:

\begin{listing}
IndentationError: expected an indented block
\end{listing}

Se você ver um erro parecido com esse, então você esqueceu de colocar os espaços na segunda linha. Os espaços em Python (ou tabs) são extremamente importantes. Nós falaremos mais sobre isso depois$\ldots$
}}}
\linebreak
\par
Nós não precisamos continuar usando o \code{range}, nós também podemos usar listas, como já criamos. Assim como a lista de compras que criamos no último capítulo:

\begin{listing}
\begin{verbatim}
>>> lista_compras = [ 'ovos', 'leite', 'queijo', 'salsinha', 'margarina', 
... 'fermento' ]
>>> for i in lista_compras:
...     print(i)
ovos
leite
queijo
salsinha
margarina
fermento
\end{verbatim}
\end{listing}

O código acima é uma forma de dizer, ``para cada item na lista, armazene na variável `i' e então imprima o conteúdo dessa variável''. Novamente, se nós não usassemos o `laço-for', nós teríamos que fazer algo assim:

\begin{listing}
\begin{verbatim}
>>> lista_compras = [ 'ovos', 'leite', 'queijo', 'salsinha', 'margarina', 
... 'fermento' ]
>>> print(lista_compras[0])
ovos
>>> print(lista_compras[1])
leite
>>> print(lista_compras[2])
queijo
>>> print(lista_compras[3])
salsinha
>>> print(lista_compras[4])
margarina
>>> print(lista_compras[5])
fermento
\end{verbatim}
\end{listing}

Então, novamente, o laço nos salvos de digitar muita coisa.

\section{Quando um bloco não é quadrado?}\index{blocks of code}

Quando é um bloco de código.
\par
\noindent
O que é um `bloco de código' então?
\par
Um bloco de código é uma série de comandos de programação que você quer juntar. Por exemplo, no laço `for' do exemplo acima, você pode querer mais que apenas imprimir os itens. Talvez você quisesse comprar cada item e então imprimí-lo. Supondo que nós tivessemos uma função chamada `comprar', você poderia escrever o código assim:

\begin{listingignore}
\begin{verbatim}
>>> for i in lista_compras:
...     comprar(i)
...     print(i)
\end{verbatim}
\end{listingignore}

Não há necessidade de tentar digitar esse exemplo no terminal do Python --- pois nós não temos uma função `comprar' e você receberá uma mensagem de erro se tentar --- mas isso demonstra um simples bloco de código em Python, formado por 2 comandos:

\begin{listingignore}
\begin{verbatim}
comprar(i)
print(i)
\end{verbatim}
\end{listingignore}

Em Python, os espaços em branco\index{white space} como o tab (quando você pressiona a tecla Tab) e o espaço (quando você aperta a barra de espaço) é \emph{muito} importante. Códigos que estão alinhados na mesma posição, são agrupados como blocos.

\begin{listing}
\begin{verbatim}
	este seria o bloco 1
	este seria o bloco 1
	este seria o bloco 1
	    este seria o bloco 2
	    este seria o bloco 2
	    este seria o bloco 2
	este ainda seria o bloco 1
	este ainda seria o bloco 1
	    este seria o bloco 3
	    este seria o bloco 3
	        este seria o bloco 4
	        este seria o bloco 4
	        este seria o bloco 4
\end{verbatim}
\end{listing}

Mas você deve ser consistente com seus espaços. Por exemplo:

\begin{listingignore}
\begin{verbatim}
>>> for i in lista_compras:
...     comprar(i)
...       print(i)
\end{verbatim}
\end{listingignore}

A segunda linha (\code{function comprar(i)}) inicia com \textbf{4} espaços. A terceira linha (\code{print(i)}) inicia com \textbf{6} espaços.  Vamos olhar novamente o código, com os espaços visíveis (usando @ no lugar):

\begin{listingignore}
\begin{verbatim}
>>> for i in lista_compras:
... @@@@comprar(i)
... @@@@@@print(i)
\end{verbatim}
\end{listingignore}

Isso causaria um erro. Assim que você começou usando 4 espaços, você precisa continuar usando 4 espaços. E se você quiser colocar um bloco \emph{dentro} de outro bloco, você precisará de 8 espaços (2 x 4) no começo de cada linha dentro desse bloco.
\par
Então o primeiro bloco tem 4 espaços (Eu vou destacar novamente, para você ver):

\begin{listing}
\begin{verbatim}
@@@@aqui está o meu primeiro bloco
@@@@aqui está o meu primeiro bloco
\end{verbatim}
\end{listing}

E então o segundo bloco (que está `dentro' do primeiro) precisa de 8 espaços:

\begin{listing}
\begin{verbatim}
@@@@aqui está o meu primeiro bloco
@@@@aqui está o meu primeiro bloco
@@@@@@@@aqui está o meu segundo bloco
@@@@@@@@aqui está o meu segundo bloco
\end{verbatim}
\end{listing}

Porque nós iriamos querer um bloco `dentro' de outro? Normalmente nós fazemos isso quando o segundo bloco depende do primeiro, de alguma forma. Como o nosso laço `for'. Se a linha com o laço é o primeiro bloco, os comandos que nós queremos executar várias vezes estará no segundo bloco --- de certa forma eles dependem do primeiro bloco para funcionar.

No terminal do Python, assim que você começar a digitar o código em um bloco, o Python continuará naquele bloco até que você pressione `Enter' em uma linha em branco (você verá os 3 pontos no começo da linha, mostrando que você ainda está em um bloco).

Vamos tentar alguns exemplos reais. Abra o terminal e digite o seguinte (lembre-se de colocar 4 espaços no começo das linhas com o comando `print'):

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)
...     print(i)
...
a
a
b
b
c
c
\end{verbatim}
\end{listing}

Após o segundo `print', pressione a tecla `Enter' em uma linha em branco --- que irá dizer ao terminal que você quer finalizar o bloco. Isso então imprimirá cada item da lista, duas vezes.
\par
\noindent
O próximo exemplo causará uma mensagem de erro:

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)
...       print(i)
...
File “<stdin>”, line 3
  print(i)
  ^
IndentationError: unexpected indent
\end{verbatim}
\end{listing}

A segunda linha tem 6 espaços, não 4, coisa que o Python não gosta, pois ele quer que os espaços se mantenham os mesmos.

\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{LEMBRE-SE}

Se você inicia o seu bloco de código com 4 espacos, você deve continuar usando 4 espaços. Se você inicia blocos com 2 espaços, você deve continuar usando 2 espaços. Continue com os 4 espaços, porque é o que as pessoas mais usam.

}}}

\par
Aqui está um exemplo mais cimplicado, com 2 blocos de código:

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)
...     for j in minhalista:
...         print(j)
...
\end{verbatim}
\end{listing}

\noindent
Onde estão os blocos nesse código e o que ele faz?
\par
\noindent
Existem \textbf{dois} blocos --- o primeiro é parte do primeiro laço `for':

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)                #
...     for j in minhalista:    # estas linhas são o PRIMEIRO bloco
...         print(j)            #
...
\end{verbatim}
\end{listing}

O segundo bloco tem somente o `print' , no segundo laço `for':

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)
...     for j in minhalista:
...         print(j)               # esta linha é o SEGUNDO bloco
...
\end{verbatim}
\end{listing}

Você consegue descobrir o que esse pequeno pedaço de código irá fazer?
\par
Ele irá imprimir as 3 letras em `minhalista', mas quantas vezes? Se nós olharmos cada linha, nós descobriremos. Nós sabemos que o primeiro laço irá caminhar por cada um dos itens na lista e então executar os comandos no bloco 1. Então ele irá imprimir uma letra, então iniciar o próximo laço. Esse laço também caminhará por cada item na lista e executará o comando no bloco 2. Então o que nós teremos quando esse código rodar, é o `a' seguido por `a', `b', `c', e então `b' seguido por `a', `b', `c' e por assim em diante. Digite o código você mesmo no terminal do Python para ver:

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)
...     for j in minhalista:
...         print(j)
... 
a
a
b
c
b
a
b
c
c
a
b
c
\end{verbatim}
\end{listing}

Que tal algo mais útil que apenas imprimir letras? Lembra daquele cálculo que usamos no começo deste livro, com intuito de saber quanto você teria no final do ano, se você ganhasse R\$5 fazendo alguns trabalhos, R\$30 por entregar alguns jornais, mas gastasse R\$10, toda semana?
\par
\noindent
Algo assim:

\begin{listing}
\begin{verbatim}
>>> (5 + 30 - 10) * 52
\end{verbatim}
\end{listing}

\noindent
(Isto é R\$5 + R\$30 - R\$10 multiplicado por 52 semanas em um ano).

Seria útil ver como as suas economias aumentaram durante o ano, ao invés de calcular quanto você teria no final do ano. Nós podemos fazer isso através de outro laço `for'. Mas antes de tudo, nós precisamos carregar esses números em variáveis:

\begin{listing}
\begin{verbatim}
>>> trabalhos = 5
>>> jornal = 30
>>> gastos = 10
\end{verbatim}
\end{listing}

Nós podemos realizar o cálculo original usando as variáveis:

\begin{listing}
\begin{verbatim}
>>> (trabalhos + jornal - gastos) * 52
1300
\end{verbatim}
\end{listing}

Ou nós podemos ver a economia aumentar durante o ano, criando outra variável chamada `economia', e usar ela no laço:

\begin{listing}
\begin{verbatim}
1. >>> economia = 0
2. >>> for semana in range(1, 53):
3. ...     economia = economia + trabalhos + jornal - gastos
4. ...     print('Semana %s = %s' % (semana, economia))
5. ...
\end{verbatim}
\end{listing}

Na linha 1, a variável `economia' é iniciada com 0 (pois nós não temos nenhuma economia ainda).\\
A linha 2 inicia o laço, que vai rodar os comandos que estão no bloco (o bloco é composto das linhas 3 e 4). Cada vez que o laço roda, a variável `semana' é carregada com o próximo número dentro da série de 1 à 52.\\
A linha 3 é um pouco mais complicada. Basicamente, a cada semana, nós queremos adicionar o que economizamos ao total economizado. Pense na variável `economia' como se fosse um banco. Juntamos o dinheiro que ganhamos fazendo alguns bicos e a entrega de jornais, subtraimos o dinheiro que gastamos e colocamos o restante no banco. Então, na linguagem de computador, a linha 3 significa: ``substitua o conteúdo da variável `economia' pela minha economia atual, mais o que eu ganhei essa semana''. Basicamente, o símbolo igual (=) é um pedaço de código `mandão' que diz algo como ``calcule algo que está à direita e salve para depois, com o nome que está à esquerda''.\\
A linha 4 possui um comando `print' um pouco mais complicado, que imprime o número da semana e o total economizado (naquela semana) na tela. Verifique a seção \emph{Truques com Strings} na página~\pageref{trickswithstrings}, se essa linha não lhe fizer muito sentido. Então, se você rodar o programa, você verá algo como abaixo:

\begin{listing}
\begin{verbatim}
Semana 1 = 25
Semana 2 = 50
Semana 3 = 75
Semana 4 = 100
Semana 5 = 125
Semana 6 = 150
Semana 7 = 175
Semana 8 = 200
Semana 9 = 225
Semana 10 = 250
Semana 11 = 275
Semana 12 = 300
Semana 13 = 325
Semana 14 = 350
Semana 15 = 375
\end{verbatim}
\end{listing}

$\ldots$até a semana 52.

\section{Já que estamos falando de laços$\ldots$}\index{while-loop}

O `for' não é o único tipo de laço que você pode fazer em Python. Existe também o laço `while' (enquanto). Se o `for' é um laço onde você sabe exatamente quando irá parar, o laço `while' é um laço onde você não sabe, necessariamente, quantas vezes irá rodar. Imagine uma escada com 20 degraus. Você sabe facilmente que pode subir 20 degraus. Isso é um laço `for'.

\begin{listing}
\begin{verbatim}
>>> for degrau in range(0,20):
...     print(degrau)
\end{verbatim}
\end{listing}

Agora imagine uma escada que sobe uma montanha. Você pode perder a energia antes de chegar no topo. Ou o tempo pode piorar, forçando você a parar a escalada. Esse é um laço `while'.

\begin{listingignore}
\begin{verbatim}
>>> degrau = 0
>>> while degrau < 10000:
...     print(degrau)
...     if cansado == True:
...         break
...     elif tempo_ruim == True:
...         break
...     else:
...         degrau = degrau + 1
\end{verbatim}
\end{listingignore}

Não se preocupe em executar o código de exemplo acima, pois nós ainda não criamos as variáveis \code{cansado} e \code{tempo\_ruim}. Mas ele demonstra um laço `while' básico. \emph{Enquanto} o valor da variável \code{degrau} for menor que 10000 (degrau $<$ 10000) o código no bloco será executado. No bloco, nós imprimimos o valor da variável \code{degrau} e então checamos se o valor de \code{cansado} ou \code{tempo\_ruim} é `True'. Se \code{cansado} for `True', então o comando \code{break} para a execução do laço (basicamente, nós pulamos para fora do laço, imediatamente para a primeira linha do próximo bloco). Se \code{tempo\_ruim} for `True', nós também paramos o laço. Se não, então \textbf{1} é somado ao valor em \code{degrau}, e a condição do laço (degrau $<$ 10000) é verificada novamente.
\par
\noindent
Então os passos de um laço `while', basicamente, são:

{\renewcommand{\labelitemi}{$\triangleright$}
\begin{itemize}
\item verifique a condição,
\item execute o código que está no bloco,
\item repita
\end{itemize}}

Geralmente, o laço `while' pode ser criado usando uma série de condições:

\begin{listing}
\begin{verbatim}
>>> x = 45
>>> y = 80
>>> while x < 50 and y < 100:
...     x = x + 1
...     y = y + 1
...     print(x, y)
\end{verbatim}
\end{listing}

Nesse laço, nós criamos uma variável \code{x} com o valor 45 e uma variável \code{y} com o valor 80. Existem duas condições que são verificadas pelo laço: quando \code{x} é menor que 50 e quando \code{y} é menor que 100. Enquanto ambas condições forem verdadeiras, o bloco de código será executado, adicionando 1 à ambas variáveis e então imprimindo-as. O resultado desse código é:

\begin{listing}
\begin{verbatim}
46 81
47 82
48 83
49 84
50 85
\end{verbatim}
\end{listing}

Talvez você possa descobrir porque esses números são impressos?\footnote{Nós iniciamos contando em 45 na variável \code{x} e em 80 na variável \code{y}, então incrementamos (somamos 1) à cada variável, toda vez que o código no laço é executado. As condições verificam que \code{x} deve ser menor que 50 e \code{y} deve ser menor que 100.  Após rodar 5 vezes (adicionando 1 a cada variável), o valor em \code{x} chega à 50. Agora a primeira condição (x $<$ 50) não é mais verdadeira, então o Python sabe que deve parar o laço.}

Outro uso comum do laço `while', é criar um laço semi-eterno. Um laço que basicamente roda para sempre, ou até que algo aconteça no código que o faça parar. Por exemplo:

\begin{listingignore}
\begin{verbatim}
>>> while True:
...     muitos códigos aqui
...     muitos códigos aqui
...     muitos códigos aqui
...     if alguma_condicao == True:
...         break
\end{verbatim}
\end{listingignore}

A condição do laço `while' é apenas `True'. Então ele sempre irá executar o código que está no bloco (assim, o laço é eterno, ou infinito). O laço somente irá parar quando a variável \code{alguma\_condicao} for verdadeira. Você pode ver um exemplo melhor disso no Apêndice~\ref{app:afewpythonmodules} (a seção sobre o módulo \code{random}), mas você poderia ler o próximo capítulo antes de pular para lá.

\section{Things to try}

\emph{In this chapter we saw how to use loops to perform repetitive tasks.  We used blocks of code inside the loops for the tasks to be repeated.}

\subsection*{Exercise 1}
What do you think will happen with the following code?

\begin{listing}
\begin{verbatim}
>>> for x in range(0, 20):
...     print('hello %s' % x)
...     if x < 9:
...         break
\end{verbatim}
\end{listing}

\subsection*{Exercise 2}
When you save money in a bank, you earn interest.  `Interest' is the money the bank pays you for letting them use your money---each year you are paid a small amount of money depending upon how much you've saved.  This payment is usually added back to your savings account at the bank, and it also makes you money$\ldots$ which is a bit confusing, so you might have to ask Mum or Dad to explain.
Interest is calculated using percentages.  If you don't know what a percentage is, don't worry, it's enough to know that if the bank is paying you 1\% (1 percent) interest, you can multiply the monetary amount by the number 0.01 (if your amount is \$1000, then you will do: 1000 * 0.01).  If they're paying you 2\% interest, you can use the number 0.02, and so on.  
If you have \$100 saved in a bank account, and they pay you 3\% interest every year, how much money do you think you will have each year, up to 10 years?  You can write a program using a for-loop to figure it out  (Hint: remember to add the interest to the total).
\newpage
