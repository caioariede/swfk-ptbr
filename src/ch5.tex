% ch5.tex
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 New Zealand License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.


\chapter{De novo e de novo}\label{ch:againandagain}

Não existe coisa pior do que ter que fazer a mesma coisa mais e mais vezes. Existe um motivo para que seus pais peçam para você contar ovelhas para tentar dormir e isso não tem nada a ver com um maravilhoso sono --- induzindo poderes de mamíferos fofinhos. Isso tem a ver com o fato de que contar infinitamente, a mesma coisa, é chato e a sua mente se desligará mais fácil para dormir, se não estiver focando em algo interessante.
\par
Além disso, especialmente os programadores não gostam de ser repetitivos. Isso os coloca para dormir de certa forma. Que é uma boa razão para que todas as linguagens de programação tenham o que é chamado de \textbf{laço-for}\index{for-loop}. Por exemplo, para imprimir `olá', 5 vezes em Python, você poderia fazer o seguinte:

\begin{listing}
\begin{verbatim}
>>> print("Olá")
Olá
>>> print("Olá")
Olá
>>> print("Olá")
Olá
>>> print("Olá")
Olá
>>> print("Olá")
Olá
\end{verbatim}
\end{listing}

Que é$\ldots$ bastante entediante.

Ou você poderia usar o `laço-for' (observe: existe 4 espaços na segunda linha, antes do comando `print' --- Eu os substituí por @ para que nós o pudessemos ver):

\begin{listingignore}
\begin{verbatim}
>>> for x in range(0, 5):
... @@@@print('Olá')
... 
Olá
Olá
Olá
Olá
Olá
\end{verbatim}
\end{listingignore}

\code{range}\index{functions!range} é uma função e uma forma rápida e fácil de criar uma lista contendo uma sequência de números entre um `início' e um `fim'. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> print(list(range(10, 20)))
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
\end{verbatim}
\end{listing}

Então, no caso do `laço-for', o código `\code{for x in range(0, 5)}' está dizendo ao Python para criar uma lista de números (0, 1, 2, 3, 4) e então para cada número, armazenar seu valor na variável \code{x}. Nós podemos então usar o \code{x} no nosso comando `print', se quisermos:

\begin{listing}
\begin{verbatim}
>>> for x in range(0, 5):
...     print('Olá %s' % x)
Olá 0
Olá 1
Olá 2
Olá 3
Olá 4
\end{verbatim}
\end{listing}

Se nos livrarmos do `laço-for' novamente, nós teríamos que fazer algo assim:

\begin{listing}
\begin{verbatim}
x = 0
print('Olá %s' % x)
x = 1
print('Olá %s' % x)
x = 2
print('Olá %s' % x)
x = 3
print('Olá %s' % x)
x = 4
print('Olá %s' % x)
\end{verbatim}
\end{listing}

Então o laço nos fez economizar, escrevendo 8 linhas a menos de código. Isso é extremamente útil, visto que um programador médio é mais preguiçoso que um hipopotamo no calor, quando o assunto é digitar. Bons programadores odeiam fazer coisas mais de uma vez, então o `laço-for' é um dos comandos mais úteis em uma linguagem de programação.

\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{AVISO!!!}

Se você esteve tentando os exemplos conforme foi lendo, você pode ter recebido uma mensagem de erro quando digitou o código para aquele `laço-for'. Se recebeu, foi algo assim:

\begin{listing}
IndentationError: expected an indented block
\end{listing}

Se você ver um erro parecido com esse, então você esqueceu de colocar os espaços na segunda linha. Os espaços em Python (ou tabs) são extremamente importantes. Nós falaremos mais sobre isso depois$\ldots$
}}}
\linebreak
\par
Nós não precisamos continuar usando o \code{range}, nós também podemos usar listas, como já criamos. Assim como a lista de compras que criamos no último capítulo:

\begin{listing}
\begin{verbatim}
>>> lista_compras = [ 'ovos', 'leite', 'queijo', 'salsinha', 'margarina', 
... 'fermento' ]
>>> for i in lista_compras:
...     print(i)
ovos
leite
queijo
salsinha
margarina
fermento
\end{verbatim}
\end{listing}

O código acima é uma forma de dizer, ``para cada item na lista, armazene na variável `i' e então imprima o conteúdo dessa variável''. Novamente, se nós não usassemos o `laço-for', nós teríamos que fazer algo assim:

\begin{listing}
\begin{verbatim}
>>> lista_compras = [ 'ovos', 'leite', 'queijo', 'salsinha', 'margarina', 
... 'fermento' ]
>>> print(lista_compras[0])
ovos
>>> print(lista_compras[1])
leite
>>> print(lista_compras[2])
queijo
>>> print(lista_compras[3])
salsinha
>>> print(lista_compras[4])
margarina
>>> print(lista_compras[5])
fermento
\end{verbatim}
\end{listing}

Então, novamente, o laço nos salvos de digitar muita coisa.

\section{Quando um bloco não é quadrado?}\index{blocks of code}

Quando é um bloco de código.
\par
\noindent
O que é um `bloco de código' então?
\par
Um bloco de código é uma série de comandos de programação que você quer juntar. Por exemplo, no laço `for' do exemplo acima, você pode querer mais que apenas imprimir os itens. Talvez você quisesse comprar cada item e então imprimí-lo. Supondo que nós tivessemos uma função chamada `comprar', você poderia escrever o código assim:

\begin{listingignore}
\begin{verbatim}
>>> for i in lista_compras:
...     comprar(i)
...     print(i)
\end{verbatim}
\end{listingignore}

Não há necessidade de tentar digitar esse exemplo no terminal do Python --- pois nós não temos uma função `comprar' e você receberá uma mensagem de erro se tentar --- mas isso demonstra um simples bloco de código em Python, formado por 2 comandos:

\begin{listingignore}
\begin{verbatim}
comprar(i)
print(i)
\end{verbatim}
\end{listingignore}

Em Python, os espaços em branco\index{white space} como o tab (quando você pressiona a tecla Tab) e o espaço (quando você aperta a barra de espaço) é \emph{muito} importante. Códigos que estão alinhados na mesma posição, são agrupados como blocos.

\begin{listing}
\begin{verbatim}
	este seria o bloco 1
	este seria o bloco 1
	este seria o bloco 1
	    este seria o bloco 2
	    este seria o bloco 2
	    este seria o bloco 2
	este ainda seria o bloco 1
	este ainda seria o bloco 1
	    este seria o bloco 3
	    este seria o bloco 3
	        este seria o bloco 4
	        este seria o bloco 4
	        este seria o bloco 4
\end{verbatim}
\end{listing}

Mas você deve ser consistente com seus espaços. Por exemplo:

\begin{listingignore}
\begin{verbatim}
>>> for i in lista_compras:
...     comprar(i)
...       print(i)
\end{verbatim}
\end{listingignore}

A segunda linha (\code{function comprar(i)}) inicia com \textbf{4} espaços. A terceira linha (\code{print(i)}) inicia com \textbf{6} espaços.  Vamos olhar novamente o código, com os espaços visíveis (usando @ no lugar):

\begin{listingignore}
\begin{verbatim}
>>> for i in lista_compras:
... @@@@comprar(i)
... @@@@@@print(i)
\end{verbatim}
\end{listingignore}

Isso causaria um erro. Assim que você começou usando 4 espaços, você precisa continuar usando 4 espaços. E se você quiser colocar um bloco \emph{dentro} de outro bloco, você precisará de 8 espaços (2 x 4) no começo de cada linha dentro desse bloco.
\par
Então o primeiro bloco tem 4 espaços (Eu vou destacar novamente, para você ver):

\begin{listing}
\begin{verbatim}
@@@@aqui está o meu primeiro bloco
@@@@aqui está o meu primeiro bloco
\end{verbatim}
\end{listing}

E então o segundo bloco (que está `dentro' do primeiro) precisa de 8 espaços:

\begin{listing}
\begin{verbatim}
@@@@aqui está o meu primeiro bloco
@@@@aqui está o meu primeiro bloco
@@@@@@@@aqui está o meu segundo bloco
@@@@@@@@aqui está o meu segundo bloco
\end{verbatim}
\end{listing}

Porque nós iriamos querer um bloco `dentro' de outro? Normalmente nós fazemos isso quando o segundo bloco depende do primeiro, de alguma forma. Como o nosso laço `for'. Se a linha com o laço é o primeiro bloco, os comandos que nós queremos executar várias vezes estará no segundo bloco --- de certa forma eles dependem do primeiro bloco para funcionar.

No terminal do Python, assim que você começar a digitar o código em um bloco, o Python continuará naquele bloco até que você pressione `Enter' em uma linha em branco (você verá os 3 pontos no começo da linha, mostrando que você ainda está em um bloco).

Vamos tentar alguns exemplos reais. Abra o terminal e digite o seguinte (lembre-se de colocar 4 espaços no começo das linhas com o comando `print'):

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)
...     print(i)
...
a
a
b
b
c
c
\end{verbatim}
\end{listing}

Após o segundo `print', pressione a tecla `Enter' em uma linha em branco --- que irá dizer ao terminal que você quer finalizar o bloco. Isso então imprimirá cada item da lista, duas vezes.
\par
\noindent
O próximo exemplo causará uma mensagem de erro:

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)
...       print(i)
...
File “<stdin>”, line 3
  print(i)
  ^
IndentationError: unexpected indent
\end{verbatim}
\end{listing}

A segunda linha tem 6 espaços, não 4, coisa que o Python não gosta, pois ele quer que os espaços se mantenham os mesmos.

\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{LEMBRE-SE}

Se você inicia o seu bloco de código com 4 espacos, você deve continuar usando 4 espaços. Se você inicia blocos com 2 espaços, você deve continuar usando 2 espaços. Continue com os 4 espaços, porque é o que as pessoas mais usam.

}}}

\par
Aqui está um exemplo mais cimplicado, com 2 blocos de código:

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)
...     for j in minhalista:
...         print(j)
...
\end{verbatim}
\end{listing}

\noindent
Onde estão os blocos nesse código e o que ele faz?
\par
\noindent
Existem \textbf{dois} blocos --- o primeiro é parte do primeiro laço `for':

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)                #
...     for j in minhalista:    # estas linhas são o PRIMEIRO bloco
...         print(j)            #
...
\end{verbatim}
\end{listing}

O segundo bloco tem somente o `print' , no segundo laço `for':

\begin{listing}
\begin{verbatim}
>>> minhalista = [ 'a', 'b', 'c' ]
>>> for i in minhalista:
...     print(i)
...     for j in minhalista:
...         print(j)               # esta linha é o SEGUNDO bloco
...
\end{verbatim}
\end{listing}

Você consegue descobrir o que esse pequeno pedaço de código irá fazer?
\par
Ele irá imprimir as 3 letras em `minhalista', mas quantas vezes? Se nós olharmos cada linha, nós descobriremos. Nós sabemos que o primeiro laço irá caminhar por cada um dos itens na lista e então executar os comandos no bloco 1. Então ele irá imprimir uma letra, então iniciar o próximo laço. Esse laço também caminhará por cada item na lista e executará o comando no bloco 2. Então o que nós teremos quando esse código rodar, é o `a' seguido por `a', `b', `c', e então `b' seguido por `a', `b', `c' e por assim em diante. Digite o código você mesmo no terminal do Python para ver:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...     for j in mylist:
...         print(j)
... 
a
a
b
c
b
a
b
c
c
a
b
c
\end{verbatim}
\end{listing}

How about something more useful than just printing letters?  Remember that calculation we came up with at the beginning of this book to work out how much you might have saved at the end of the year, if you earned \$5 doing chores, \$30 doing a paper route and spent \$10 a week?
\par
\noindent
It looked like this:

\begin{listing}
\begin{verbatim}
>>> (5 + 30 - 10) * 52
\end{verbatim}
\end{listing}

\noindent
(That's \$5 + \$30 - \$10 multiplied by 52 weeks in the year).

It might be useful to see how much your savings are increasing during the year, rather than working out what they will be at the very end.  We can do this with another for-loop.  But first of all, we need to load those numbers into variables:

\begin{listing}
\begin{verbatim}
>>> chores = 5
>>> paper = 30
>>> spending = 10
\end{verbatim}
\end{listing}

We can perform the original calculation using the variables:

\begin{listing}
\begin{verbatim}
>>> (chores + paper - spending) * 52
1300
\end{verbatim}
\end{listing}

Or we can see the savings increase over the year, by creating another variable called savings, and then using a loop:

\begin{listing}
\begin{verbatim}
1. >>> savings = 0
2. >>> for week in range(1, 53):
3. ...     savings = savings + chores + paper - spending
4. ...     print('Week %s = %s' % (week, savings))
5. ...
\end{verbatim}
\end{listing}

On line 1 the variable `savings' is loaded with 0 (because we haven't saved anything yet).\\
Line 2 sets up the for-loop, which will run the commands in the block (the block is made up of lines 3 and 4).  Each time it loops, the variable week is loaded with the next number in the range 1-52.\\
Line 3 is a bit more complicated.  Basically, each week we want to add what we've saved to our total savings.  Think of the variable `savings' as something like a bank.  We add up the money we earn doing odd jobs and the paper route, subtract our spending money and then take the rest to the bank.  So in computer-speak, line 3 really means, ``replace the contents of the variable savings with my current savings, plus what I've earned this week''. Basically, the equals symbol (=) is a bossy piece of code that is a way of saying, ``work out some stuff on the right first and then save it for later, using the name on the left''.\\
Line 4 is a slightly more complicated print statement, which prints the week number and the total amount saved (for that week) to the screen.  Check the section \emph{Tricks with Strings} on page~\pageref{trickswithstrings}, if this line doesn't make a lot of sense to you. So, if you run this program, you'll see something like the following$\ldots$

\begin{listing}
\begin{verbatim}
Week 1 = 25
Week 2 = 50
Week 3 = 75
Week 4 = 100
Week 5 = 125
Week 6 = 150
Week 7 = 175
Week 8 = 200
Week 9 = 225
Week 10 = 250
Week 11 = 275
Week 12 = 300
Week 13 = 325
Week 14 = 350
Week 15 = 375
\end{verbatim}
\end{listing}

$\ldots$going all the way up to week 52.

\section{While we're talking about looping$\ldots$}\index{while-loop}

A for-loop isn't the only kind of looping you can do in Python. There's also the while-loop. If a for-loop is a loop where you know exactly when you'll stop running, a while-loop is a loop where you don't necessarily know ahead of time when you'll stop. Imagine a staircase with 20 steps.  You know you can easily climb 20 steps.  That's a for-loop.

\begin{listing}
\begin{verbatim}
>>> for step in range(0,20):
...     print(step)
\end{verbatim}
\end{listing}

Now imagine a staircase going up a mountainside.  You might run out of energy before you reach the top.  Or the weather might turn bad forcing you to stop climbing.  This is a while-loop.

\begin{listingignore}
\begin{verbatim}
>>> step = 0
>>> while step < 10000:
...     print(step)
...     if tired == True:
...         break
...     elif badweather == True:
...         break
...     else:
...         step = step + 1
\end{verbatim}
\end{listingignore}

Don't bother running the code sample above, because we haven't bothered to create the variables \code{tired} and \code{badweather}.  But it demonstrates the basics of a while-loop.  \emph{While} the value of variable \code{step} is less than 10000 (step $<$ 10000) the code in the block is executed.  In the block, we print the value of \code{step}, then check whether \code{tired} or \code{badweather} is true.  If \code{tired} is true, then the \code{break} statement stops the code in the loop executing (basically we jump out of the loop to the next line of code immediately following the block).  If \code{badweather} is true, we also break out of the loop.  If not, then \textbf{1} is added to the value of \code{step}, and the condition of the while loop (step $<$ 10000) is checked again.
\par
\noindent
So the steps of a while loop are basically:

{\renewcommand{\labelitemi}{$\triangleright$}
\begin{itemize}
\item check the condition,
\item execute the code in the block,
\item repeat
\end{itemize}}

More commonly, a while-loop might be created with a couple of conditions:

\begin{listing}
\begin{verbatim}
>>> x = 45
>>> y = 80
>>> while x < 50 and y < 100:
...     x = x + 1
...     y = y + 1
...     print(x, y)
\end{verbatim}
\end{listing}

In this loop, we create a variable \code{x} with the value 45, and a variable \code{y} with the value 80.  There are two conditions that are checked by the loop: whether \code{x} is less than 50 and whether \code{y} is less than 100. While both conditions are true, the block of code is executed, adding 1 to both variables and then printing them. The output of this code is just:

\begin{listing}
\begin{verbatim}
46 81
47 82
48 83
49 84
50 85
\end{verbatim}
\end{listing}

Maybe you can figure out why these numbers are printed?\footnote{We start counting at 45 in the variable \code{x} and at 80 in the variable \code{y}, and then increment (add one) to each variable every time the code in the loop is run.  The conditions check that \code{x} must be less than 50 and \code{y} must be less than 100.  After looping five times (adding 1 to each variable) the value in x reaches 50.  Now the first condition (x $<$ 50) is no longer true, so Python knows to stop looping.}

Another common usage of a while-loop, is to create a semi-eternal loop. This is a loop that basically goes forever, or at least until something happens in the code to break out of it. For example:

\begin{listingignore}
\begin{verbatim}
>>> while True:
...     lots of code here
...     lots of code here
...     lots of code here
...     if some_condition == True:
...         break
\end{verbatim}
\end{listingignore}

The condition for the while loop is just `True'.  So it will always run the code in the block (thus the loop is eternal or infinite). Only if the variable some\_condition is true will the code break out of the loop.  You can see a better example of this in Appendix~\ref{app:afewpythonmodules} (the section about the \code{random} module), but you might want to wait until you've read the next chapter before taking a look at it.

\section{Things to try}

\emph{In this chapter we saw how to use loops to perform repetitive tasks.  We used blocks of code inside the loops for the tasks to be repeated.}

\subsection*{Exercise 1}
What do you think will happen with the following code?

\begin{listing}
\begin{verbatim}
>>> for x in range(0, 20):
...     print('hello %s' % x)
...     if x < 9:
...         break
\end{verbatim}
\end{listing}

\subsection*{Exercise 2}
When you save money in a bank, you earn interest.  `Interest' is the money the bank pays you for letting them use your money---each year you are paid a small amount of money depending upon how much you've saved.  This payment is usually added back to your savings account at the bank, and it also makes you money$\ldots$ which is a bit confusing, so you might have to ask Mum or Dad to explain.
Interest is calculated using percentages.  If you don't know what a percentage is, don't worry, it's enough to know that if the bank is paying you 1\% (1 percent) interest, you can multiply the monetary amount by the number 0.01 (if your amount is \$1000, then you will do: 1000 * 0.01).  If they're paying you 2\% interest, you can use the number 0.02, and so on.  
If you have \$100 saved in a bank account, and they pay you 3\% interest every year, how much money do you think you will have each year, up to 10 years?  You can write a program using a for-loop to figure it out  (Hint: remember to add the interest to the total).
\newpage
