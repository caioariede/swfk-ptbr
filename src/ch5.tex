% ch5.tex
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 New Zealand License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.


\chapter{De novo e de novo}\label{ch:againandagain}

Não existe coisa pior do que ter que fazer a mesma coisa mais e mais vezes. Existe um motivo para que seus pais peçam para você contar ovelhas para tentar dormir e isso não tem nada a ver com um maravilhoso sono --- induzindo poderes de mamíferos fofinhos. Isso tem a ver com o fato de que contar infinitamente, a mesma coisa, é chato e a sua mente se desligará mais fácil para dormir, se não estiver focando em algo interessante.
\par
Além disso, especialmente os programadores não gostam de ser repetitivos. Isso os coloca para dormir de certa forma. Que é uma boa razão para que todas as linguagens de programação tenham o que é chamado de \textbf{laço-for}\index{for-loop}. Por exemplo, para imprimir `olá', 5 vezes em Python, você poderia fazer o seguinte:

\begin{listing}
\begin{verbatim}
>>> print("Olá")
Olá
>>> print("Olá")
Olá
>>> print("Olá")
Olá
>>> print("Olá")
Olá
>>> print("Olá")
Olá
\end{verbatim}
\end{listing}

Que é$\ldots$ bastante entediante.

Ou você poderia usar o `laço-for' (observe: existe 4 espaços na segunda linha, antes do comando `print' --- Eu os substituí por @ para que nós o pudessemos ver):

\begin{listingignore}
\begin{verbatim}
>>> for x in range(0, 5):
... @@@@print('Olá')
... 
Olá
Olá
Olá
Olá
Olá
\end{verbatim}
\end{listingignore}

\code{range}\index{functions!range} é uma função e uma forma rápida e fácil de criar uma lista contendo uma sequência de números entre um `início' e um `fim'. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> print(list(range(10, 20)))
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
\end{verbatim}
\end{listing}

Então, no caso do `laço-for', o código `\code{for x in range(0, 5)}' está dizendo ao Python para criar uma lista de números (0, 1, 2, 3, 4) e então para cada número, armazenar seu valor na variável \code{x}. Nós podemos então usar o \code{x} no nosso comando `print', se quisermos:

\begin{listing}
\begin{verbatim}
>>> for x in range(0, 5):
...     print('Olá %s' % x)
Olá 0
Olá 1
Olá 2
Olá 3
Olá 4
\end{verbatim}
\end{listing}

Se nos livrarmos do `laço-for' novamente, nós teríamos que fazer algo assim:

\begin{listing}
\begin{verbatim}
x = 0
print('Olá %s' % x)
x = 1
print('Olá %s' % x)
x = 2
print('Olá %s' % x)
x = 3
print('Olá %s' % x)
x = 4
print('Olá %s' % x)
\end{verbatim}
\end{listing}

Então o laço nos fez economizar, escrevendo 8 linhas a menos de código. Isso é extremamente útil, visto que um programador médio é mais preguiçoso que um hipopotamo no calor, quando o assunto é digitar. Bons programadores odeiam fazer coisas mais de uma vez, então o `laço-for' é um dos comandos mais úteis em uma linguagem de programação.

\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{AVISO!!!}

Se você esteve tentando os exemplos conforme foi lendo, você pode ter recebido uma mensagem de erro quando digitou o código para aquele `laço-for'. Se recebeu, foi algo assim:

\begin{listing}
IndentationError: expected an indented block
\end{listing}

Se você ver um erro parecido com esse, então você esqueceu de colocar os espaços na segunda linha. Os espaços em Python (ou tabs) são extremamente importantes. Nós falaremos mais sobre isso depois$\ldots$
}}}
\linebreak
\par
Nós não precisamos continuar usando o \code{range}, nós também podemos usar listas, como já criamos. Assim como a lista de compras que criamos no último capítulo:

\begin{listing}
\begin{verbatim}
>>> lista_compras = [ 'ovos', 'leite', 'queijo', 'salsinha', 'margarina', 
... 'fermento' ]
>>> for i in lista_compras:
...     print(i)
ovos
leite
queijo
salsinha
margarina
fermento
\end{verbatim}
\end{listing}

O código acima é uma forma de dizer, ``para cada item na lista, armazene na variável `i' e então imprima o conteúdo dessa variável''. Novamente, se nós não usassemos o `laço-for', nós teríamos que fazer algo assim:

\begin{listing}
\begin{verbatim}
>>> lista_compras = [ 'ovos', 'leite', 'queijo', 'salsinha', 'margarina', 
... 'fermento' ]
>>> print(lista_compras[0])
ovos
>>> print(lista_compras[1])
leite
>>> print(lista_compras[2])
queijo
>>> print(lista_compras[3])
salsinha
>>> print(lista_compras[4])
margarina
>>> print(lista_compras[5])
fermento
\end{verbatim}
\end{listing}

Então, novamente, o laço nos salvos de digitar muita coisa.

\section{Quando um bloco não é quadrado?}\index{blocks of code}

Quando é um bloco de código.
\par
\noindent
O que é um `bloco de código' então?
\par
Um bloco de código é uma série de comandos de programação que você quer juntar. Por exemplo, no laço `for' do exemplo acima, você pode querer mais que apenas imprimir os itens. Talvez você quisesse comprar cada item e então imprimí-lo. Supondo que nós tivessemos uma função chamada `comprar', você poderia escrever o código assim:

\begin{listingignore}
\begin{verbatim}
>>> for i in lista_compras:
...     comprar(i)
...     print(i)
\end{verbatim}
\end{listingignore}

Não há necessidade de tentar digitar esse exemplo no terminal do Python --- pois nós não temos uma função `comprar' e você receberá uma mensagem de erro se tentar --- mas isso demonstra um simples bloco de código em Python, formado por 2 comandos:

\begin{listingignore}
\begin{verbatim}
comprar(i)
print(i)
\end{verbatim}
\end{listingignore}

Em Python, os espaços em branco\index{white space} como o tab (quando você pressiona a tecla Tab) e o espaço (quando você aperta a barra de espaço) é \emph{muito} importante. Códigos que estão alinhados na mesma posição, são agrupados como blocos.

\begin{listing}
\begin{verbatim}
	this would be block 1
	this would be block 1
	this would be block 1
	    this would be block 2
	    this would be block 2
	    this would be block 2
	this would still be block 1
	this would still be block 1
	    this would be block 3
	    this would be block 3
	        this would be block 4
	        this would be block 4
	        this would be block 4
\end{verbatim}
\end{listing}

But you must be consistent with your spacing.  For example:

\begin{listingignore}
\begin{verbatim}
>>> for i in shopping_list:
...     buy(i)
...       print(i)
\end{verbatim}
\end{listingignore}

The second line (\code{function buy(i)}) starts with \textbf{4} spaces.  The third line (print(i)) starts with \textbf{6} spaces.  Let's take another look at that code with visible spaces (using @ again):

\begin{listingignore}
\begin{verbatim}
>>> for i in shopping_list:
... @@@@buy(i)
... @@@@@@print(i)
\end{verbatim}
\end{listingignore}

This would cause an error.  Once you start using 4 spaces, you need to continue using 4 spaces.  And if you want to put a block \emph{inside} another block, you'll need 8 spaces (2 x 4) at the beginning of the lines for that inner block.
\par
So the first block has 4 spaces (I'll highlight them again so you can see them):

\begin{listing}
\begin{verbatim}
@@@@here's my first block
@@@@here's my first block
\end{verbatim}
\end{listing}

And then the second block (which is `inside' the first) needs 8 spaces:

\begin{listing}
\begin{verbatim}
@@@@here's my first block
@@@@here's my first block
@@@@@@@@here's my second block
@@@@@@@@here's my second block
\end{verbatim}
\end{listing}

Why do we want to put one block `inside' another?  Usually we do this when the second block relies on the first in some way.  Such as our for-loop.  If the line with the for-loop is the first block, then the statements we want to run over and over again are in the second block---in a way they rely on the first block to work properly.

In the Python console, once you start typing code in a block, Python continues that block until you press the Enter key on a blank line (you'll see the 3 dots at the beginning of the line showing that you're still inside a block.

Let's try some real examples.  Open the console and type the following (remember that you need to press the space bar 4 times at the beginning of the print lines):

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...     print(i)
...
a
a
b
b
c
c
\end{verbatim}
\end{listing}

After the second print, press the Enter key on the blank line---which tells the console you want to end the block. It will then print each item in the list twice.
\par
\noindent
The next example will cause an error message to be displayed:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...       print(i)
...
File “<stdin>”, line 3
  print(i)
  ^
IndentationError: unexpected indent
\end{verbatim}
\end{listing}

The second print line has 6 spaces, not 4, which Python doesn't like because it wants spacing to stay the same.

\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{REMEMBER}

If you start your blocks of code with 4 spaces you must continue using 4 spaces.  If you start blocks with 2 spaces, you must continue with 2 spaces.  Stick to 4 spaces, because that's what most people use.

}}}

\par
Here's a more complicated example with 2 blocks of code:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...     for j in mylist:
...         print(j)
...
\end{verbatim}
\end{listing}

\noindent
Where are the blocks in this code and what is it going to do...?
\par
\noindent
There are \textbf{two} blocks---number one is part of the first for-loop:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)                #
...     for j in mylist:        #-- these lines are the FIRST block
...         print(j)            #
...
\end{verbatim}
\end{listing}

Block number two is the single print line in the second for-loop:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...     for j in mylist:
...         print(j)               # this line is the SECOND block
...
\end{verbatim}
\end{listing}

Can you figure out what this little bit of code is going to do?
\par
It's going to print out the 3 letters from `mylist', but how many times?  If we look at each line, we can probably figure out the number. We know that the first loop statement will go through each of the items in the list, and then run the commands in block number 1. So it will print out a letter, then start the next loop. This loop will also go through each of the items in the list and then run the command in block number 2.  So what we should get when this code runs, is `a' followed by `a', `b', `c', then `b' followed by `a', `b', `c' and so on. Enter the code into the Python console and see for yourself:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...     for j in mylist:
...         print(j)
... 
a
a
b
c
b
a
b
c
c
a
b
c
\end{verbatim}
\end{listing}

How about something more useful than just printing letters?  Remember that calculation we came up with at the beginning of this book to work out how much you might have saved at the end of the year, if you earned \$5 doing chores, \$30 doing a paper route and spent \$10 a week?
\par
\noindent
It looked like this:

\begin{listing}
\begin{verbatim}
>>> (5 + 30 - 10) * 52
\end{verbatim}
\end{listing}

\noindent
(That's \$5 + \$30 - \$10 multiplied by 52 weeks in the year).

It might be useful to see how much your savings are increasing during the year, rather than working out what they will be at the very end.  We can do this with another for-loop.  But first of all, we need to load those numbers into variables:

\begin{listing}
\begin{verbatim}
>>> chores = 5
>>> paper = 30
>>> spending = 10
\end{verbatim}
\end{listing}

We can perform the original calculation using the variables:

\begin{listing}
\begin{verbatim}
>>> (chores + paper - spending) * 52
1300
\end{verbatim}
\end{listing}

Or we can see the savings increase over the year, by creating another variable called savings, and then using a loop:

\begin{listing}
\begin{verbatim}
1. >>> savings = 0
2. >>> for week in range(1, 53):
3. ...     savings = savings + chores + paper - spending
4. ...     print('Week %s = %s' % (week, savings))
5. ...
\end{verbatim}
\end{listing}

On line 1 the variable `savings' is loaded with 0 (because we haven't saved anything yet).\\
Line 2 sets up the for-loop, which will run the commands in the block (the block is made up of lines 3 and 4).  Each time it loops, the variable week is loaded with the next number in the range 1-52.\\
Line 3 is a bit more complicated.  Basically, each week we want to add what we've saved to our total savings.  Think of the variable `savings' as something like a bank.  We add up the money we earn doing odd jobs and the paper route, subtract our spending money and then take the rest to the bank.  So in computer-speak, line 3 really means, ``replace the contents of the variable savings with my current savings, plus what I've earned this week''. Basically, the equals symbol (=) is a bossy piece of code that is a way of saying, ``work out some stuff on the right first and then save it for later, using the name on the left''.\\
Line 4 is a slightly more complicated print statement, which prints the week number and the total amount saved (for that week) to the screen.  Check the section \emph{Tricks with Strings} on page~\pageref{trickswithstrings}, if this line doesn't make a lot of sense to you. So, if you run this program, you'll see something like the following$\ldots$

\begin{listing}
\begin{verbatim}
Week 1 = 25
Week 2 = 50
Week 3 = 75
Week 4 = 100
Week 5 = 125
Week 6 = 150
Week 7 = 175
Week 8 = 200
Week 9 = 225
Week 10 = 250
Week 11 = 275
Week 12 = 300
Week 13 = 325
Week 14 = 350
Week 15 = 375
\end{verbatim}
\end{listing}

$\ldots$going all the way up to week 52.

\section{While we're talking about looping$\ldots$}\index{while-loop}

A for-loop isn't the only kind of looping you can do in Python. There's also the while-loop. If a for-loop is a loop where you know exactly when you'll stop running, a while-loop is a loop where you don't necessarily know ahead of time when you'll stop. Imagine a staircase with 20 steps.  You know you can easily climb 20 steps.  That's a for-loop.

\begin{listing}
\begin{verbatim}
>>> for step in range(0,20):
...     print(step)
\end{verbatim}
\end{listing}

Now imagine a staircase going up a mountainside.  You might run out of energy before you reach the top.  Or the weather might turn bad forcing you to stop climbing.  This is a while-loop.

\begin{listingignore}
\begin{verbatim}
>>> step = 0
>>> while step < 10000:
...     print(step)
...     if tired == True:
...         break
...     elif badweather == True:
...         break
...     else:
...         step = step + 1
\end{verbatim}
\end{listingignore}

Don't bother running the code sample above, because we haven't bothered to create the variables \code{tired} and \code{badweather}.  But it demonstrates the basics of a while-loop.  \emph{While} the value of variable \code{step} is less than 10000 (step $<$ 10000) the code in the block is executed.  In the block, we print the value of \code{step}, then check whether \code{tired} or \code{badweather} is true.  If \code{tired} is true, then the \code{break} statement stops the code in the loop executing (basically we jump out of the loop to the next line of code immediately following the block).  If \code{badweather} is true, we also break out of the loop.  If not, then \textbf{1} is added to the value of \code{step}, and the condition of the while loop (step $<$ 10000) is checked again.
\par
\noindent
So the steps of a while loop are basically:

{\renewcommand{\labelitemi}{$\triangleright$}
\begin{itemize}
\item check the condition,
\item execute the code in the block,
\item repeat
\end{itemize}}

More commonly, a while-loop might be created with a couple of conditions:

\begin{listing}
\begin{verbatim}
>>> x = 45
>>> y = 80
>>> while x < 50 and y < 100:
...     x = x + 1
...     y = y + 1
...     print(x, y)
\end{verbatim}
\end{listing}

In this loop, we create a variable \code{x} with the value 45, and a variable \code{y} with the value 80.  There are two conditions that are checked by the loop: whether \code{x} is less than 50 and whether \code{y} is less than 100. While both conditions are true, the block of code is executed, adding 1 to both variables and then printing them. The output of this code is just:

\begin{listing}
\begin{verbatim}
46 81
47 82
48 83
49 84
50 85
\end{verbatim}
\end{listing}

Maybe you can figure out why these numbers are printed?\footnote{We start counting at 45 in the variable \code{x} and at 80 in the variable \code{y}, and then increment (add one) to each variable every time the code in the loop is run.  The conditions check that \code{x} must be less than 50 and \code{y} must be less than 100.  After looping five times (adding 1 to each variable) the value in x reaches 50.  Now the first condition (x $<$ 50) is no longer true, so Python knows to stop looping.}

Another common usage of a while-loop, is to create a semi-eternal loop. This is a loop that basically goes forever, or at least until something happens in the code to break out of it. For example:

\begin{listingignore}
\begin{verbatim}
>>> while True:
...     lots of code here
...     lots of code here
...     lots of code here
...     if some_condition == True:
...         break
\end{verbatim}
\end{listingignore}

The condition for the while loop is just `True'.  So it will always run the code in the block (thus the loop is eternal or infinite). Only if the variable some\_condition is true will the code break out of the loop.  You can see a better example of this in Appendix~\ref{app:afewpythonmodules} (the section about the \code{random} module), but you might want to wait until you've read the next chapter before taking a look at it.

\section{Things to try}

\emph{In this chapter we saw how to use loops to perform repetitive tasks.  We used blocks of code inside the loops for the tasks to be repeated.}

\subsection*{Exercise 1}
What do you think will happen with the following code?

\begin{listing}
\begin{verbatim}
>>> for x in range(0, 20):
...     print('hello %s' % x)
...     if x < 9:
...         break
\end{verbatim}
\end{listing}

\subsection*{Exercise 2}
When you save money in a bank, you earn interest.  `Interest' is the money the bank pays you for letting them use your money---each year you are paid a small amount of money depending upon how much you've saved.  This payment is usually added back to your savings account at the bank, and it also makes you money$\ldots$ which is a bit confusing, so you might have to ask Mum or Dad to explain.
Interest is calculated using percentages.  If you don't know what a percentage is, don't worry, it's enough to know that if the bank is paying you 1\% (1 percent) interest, you can multiply the monetary amount by the number 0.01 (if your amount is \$1000, then you will do: 1000 * 0.01).  If they're paying you 2\% interest, you can use the number 0.02, and so on.  
If you have \$100 saved in a bank account, and they pay you 3\% interest every year, how much money do you think you will have each year, up to 10 years?  You can write a program using a for-loop to figure it out  (Hint: remember to add the interest to the total).
\newpage
