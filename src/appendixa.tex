% appendixa.tex
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 New Zealand License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

\chapter{Palavras-chave em Python}\label{app:pythonkeywords}

Palavras-chave em Python (na verdade, na maioria das linguagens de programação), são palavras importantes, usadas pela própria linguagem. Se você tentar usar algumas dessas palavras especiais como nomes de variáveis, ou usá-las de forma incorreta, você verá um erro estranho (algumas vezes engraçado, outras confuso), no terminal do Python. Abaixo está cada uma das palavras-chave em Python e uma breve descrição.

\subsection*{and}\index{keywords!and}

A palavra-chave \textbf{and} é usada para juntar duas expressões em uma só declaração (por exemplo, o `if'), para dizer que essas duas expressões precisam ser verdadeiras. Por exemplo:

\begin{listingignore}
\begin{verbatim}
if idade > 10 and idade < 20
\end{verbatim}
\end{listingignore}

\noindent
Isso significa que a idade deve ser maior que 10 \textbf{e} menor que 20.

\subsection*{as}\index{keywords!as}

A palavra-chave \textbf{as} é usada para dar um outro nome à um módulo importado. Por exemplo, se você tem um módulo com o seguinte nome:

\begin{listingignore}
\begin{verbatim}
eu_sou_um_modulo_do_python_nao_muito_util
\end{verbatim}
\end{listingignore}

\noindent
Seria muito chato ter que digitar o nome do módulo toda vez que você quisesse usá-lo:

\begin{listingignore}
\begin{verbatim}
>>> import eu_sou_um_modulo_do_python_nao_muito_util
>>>
>>> eu_sou_um_modulo_do_python_nao_muito_util.faca_algo()
Fiz algo
>>> eu_sou_um_modulo_do_python_nao_muito_util.faca_outra_coisa()
Fiz outra coisa!
\end{verbatim}
\end{listingignore}

\noindent
Ao invés disso, você pode dar um nome assim que importá-lo e então apenas usar o novo nome (como se fosse um apelido):

\begin{listingignore}
\begin{verbatim}
>>> import eu_sou_um_modulo_do_python_nao_muito_util as poucoutil
>>>
>>> poucoutil.faca_algo_something()
Fiz algo

>>> poucoutil.faca_outra_coisa()
Fiz outra coisa!
\end{verbatim}
\end{listingignore}

\noindent
Apesar de que você não usará a palavra-chave `as' muitas vezes.

\subsection*{assert}\index{keywords!assert}

A palavra-chave \textbf{assert} é uma palavra-chave avançada, que é usada por programadores quando eles querem assegurar que um código seja verdadeiro (ou `True'). É uma outra forma de capturar erros e problemas em um código --- e normalmente usado em programas mais avançados.

\subsection*{break}\index{keywords!break}

A palavra-chave \textbf{break} é usada para parar algum código que está executando. Você deverá usar o `break' dentro de um laço `for':

\begin{listing}
\begin{verbatim}
>>> idade = 25
>>> for x in range(1, 100):
...     print('contando %s' % x)
...     if x == idade:
...         print('fim da contagem')
...         break
\end{verbatim}
\end{listing}

\noindent
Se a variável `idade' for 10, isso é o que será impresso:

\begin{listing}
\begin{verbatim}
contando 1
contando 2
contando 3
contando 4
contando 5
contando 6
contando 7
contando 8
contando 9
contando 10
fim da contagem
\end{verbatim}
\end{listing}

\noindent
Confira o Capítulo~\ref{ch:againandagain} para mais informações sobre os laços `for'.

\subsection*{class}\index{keywords!class}

A palavra-chave \textbf{class} é usada para definir um tipo de objeto. Essa é uma característica presente em muitas linguagens de programação e é muito útil quando estamos desenvolvendo programas mais complicados, mas esse é um assunto um pouco avançado para este livro.

\subsection*{del}\index{keywords!del}

`del' é uma função especial, usada para se livrar de algo. Por exemplo, se você tem uma lista em um diário, contendo os presentes que quer de aniversário, mas mudou de ideia, você poderia riscá-lo da lista, e adicionar um novo:

\begin{center}
\includegraphics*[width=70mm]{eps/list.eps}
\end{center}

\noindent
Se tivéssemos a mesma lista em Python:

\begin{listing}
\begin{verbatim}
>>> eu_quero = ['carrinho de controle remoto', 'bicicleta', 'video-game']
\end{verbatim}
\end{listing}

\noindent
Nós poderíamos remover o video-game, usando o \code{del} e adicionando o novo ítem usando a função `append':

\begin{listing}
\begin{verbatim}
>>> del eu_quero[2]
>>> eu_quero.append('robô-dinossauro')
\end{verbatim}
\end{listing}

\noindent
E então, para ver a nova lista:

\begin{listing}
\begin{verbatim}
>>> print(eu_quero)
['carrinho de controle remoto', 'bicicleta', 'robô-dinossauro']
\end{verbatim}
\end{listing}

\noindent
Veja o Capítulo~\ref{ch:8multipliedby3.57} para mais informações sobre listas.

\subsection*{elif}\index{keywords!elif}

A palavra-chave \textbf{elif} é usada como uma parte da condição `if'. Veja sobre o \textbf{if} mais abaixo...

\subsection*{else}\index{keywords!else}

A palavra-chave \textbf{else} também é usada como uma parte da condição `if'. Veja sobre o \textbf{if} mais abaixo...

\subsection*{except}\index{keywords!except}

Outra palavra-chave para capturar problemas no código. Novamente, o uso desta é para programas mais complicados, muito avançado para este livro.

\subsection*{exec}\index{keywords!exec}

O \textbf{exec} é uma função especial, usada para que uma string seja executada como se fosse um código Python. Por exemplo, você quer criar uma variável com uma string de valor, como abaixo:

\begin{listing}
\begin{verbatim}
>>> minhavar = 'ola!'
\end{verbatim}
\end{listing}

\noindent
E imprimir o seu conteúdo:

\begin{listing}
\begin{verbatim}
>>> print(minhavar)
ola!
\end{verbatim}
\end{listing}

\noindent
Mas você também poderia colocar um código em Python dentro de uma string:

\begin{listing}
\begin{verbatim}
>>> minhavar = 'print("ola!")'
\end{verbatim}
\end{listing}

\noindent
E então você poderia usar o `exec' para tornar essa string em um mini programa Python e executá-lo:

\begin{listing}
\begin{verbatim}
>>> exec(minhavar)
ola!
\end{verbatim}
\end{listing}

Parece uma ideia um pouco estranha e talvez seja algo que não fará sentido até você precisar usar. Como o \code{assert}, essa é uma das palavras-chave avançadas que é usada em programas mais sofisticados.

\subsection*{finally}\index{keywords!finally}

Esta é outra palavra-chave avaçada, usada para assegurar que, quando um erro ocorrer, um código em especial será executado (normalmente para limpar a 'bagunça' que um outro código deixou para trás).

\subsection*{for}\index{keywords!for}

A palavra-chave \textbf{for} é usada para criar um laço `for' de alguma forma. Por exemplo:

\begin{listing}
\begin{verbatim}
for x in range(0, 5):
    print('x é %s' % x)
\end{verbatim}
\end{listing}

\noindent
O laço `for' acima, executa um bloco de código (o comando `print') 5 vezes, criando a seguinte saída:

\begin{listing}
\begin{verbatim}
x é 0
x é 1
x é 2
x é 3
x é 4
\end{verbatim}
\end{listing}

\subsection*{from}\index{keywords!from}

Enquanto importando um módulo, você pode querer importar apenas uma parte que você precisa, usando a palavra-chave \textbf{from}. Por exemplo, o módulo `turtle' tem uma função chamada \code{Pen()} que é usada para criar um objeto do tipo `Pen' (basicamente uma tela onde a tartaruga se moverá) --- você pode importar o módulo inteiro e então usar a função \code{Pen}, como abaixo:

\begin{listingignore}
\begin{verbatim}
>>> import turtle
>>> t = turtle.Pen()
\end{verbatim}
\end{listingignore}

Ou, você pode importar apenas a função \code{Pen} e então usá-la diretamente (sem precisar referenciar o módulo `turtle' por completo):

\begin{listingignore}
\begin{verbatim}
>>> from turtle import Pen
>>> t = Pen()
\end{verbatim}
\end{listingignore}

E é claro que isso significa que você não poderá usar outras partes do módulo que você não importou. Por exemplo, o módulo `time' tem uma função chamada `localtime` e outra `gmtime'. Se nós importarmos o `localtime' e então tentarmos usar a `gmtime', teremos um erro:

\begin{listingignore}
\begin{verbatim}
>>> from time import localtime
>>> print(localtime())
(2007, 1, 30, 20, 53, 42, 1, 30, 0)
\end{verbatim}
\end{listingignore}

\noindent
Isso funciona, mas isso:

\begin{listing}
\begin{verbatim}
>>> print(gmtime())
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'gmtime' is not defined
\end{verbatim}
\end{listing}

A mensagem ```gmtime' is not defined'' indica que o Python não sabe da função \code{gmtime}$\ldots$ ainda. Se houverem um monte de funções em um módulo que você quer usar e você não quer referenciar o nome do módulo toda vez que usá-las (ex. \code{time.localtime}, ou \code{time.outra\_coisa}), você pode importar tudo do módulo, de uma só vez, usando o asterísco (*):

\begin{listingignore}
\begin{verbatim}
>>> from time import *
>>> print(localtime())
(2007, 1, 30, 20, 57, 7, 1, 30, 0)
>>> print(gmtime())
(2007, 1, 30, 13, 57, 9, 1, 30, 0)
\end{verbatim}
\end{listingignore}

Neste caso, nós importamos tudo do módulo `time' e podemos referenciar as funções individualmente pelo nome.

\subsection*{global}\index{keywords!global}

No Capítulo~\ref{ch:sortoflikerecycling}, nós falamos sobre \emph{escopo}. Escopo é a `visibilidade' de uma variável. Se a variável é definida fora de uma função, normalmente ela pode ser vista dentro da função. Se definida dentro de uma função, normalmente ela não pode ser vista \textbf{de fora} dessa função.
\par
A palavra-chave \code{global} é uma exceção à essa regra. Uma variável que é definida como global, pode ser vista de qualquer lugar. A definição da palavra `global' é `universal', então você pode pensar no terminal do Python como sendo um universo. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> def teste():
...     global a
...     a = 1
...     b = 2
\end{verbatim}
\end{listing}

O que você acha que acontece quando você chamar \code{print(a)} e então \code{print(b)} depois de executar a função teste? O primeiro irá funcionar, o segundo então causará um erro:

\begin{listing}
\begin{verbatim}
>>> teste()
>>> print(a)
1
>>> print(b)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'b' is not defined
\end{verbatim}
\end{listing}

A variável \code{a} é global agora (visível por todo mundo), mas \code{b} ainda é uma variável visível apenas dentro da função. Observe que você deve chamar \code{global} antes de salvar ou usar a sua variável global.

\subsection*{if}\index{keywords!if}

Uma expressão tomando uma decisão sobre algo --- que em algumas vezes é usado com algumas palavras-chave adicionais como \code{else} (senão) e o \code{elif} (else if / senão se). Uma expressão `if' é uma forma de dizer, ``se algo for verdade, então faça uma ação''. Por exemplo:

\begin{listing}
\begin{verbatim}
if preco_brinquedo > 1000:
    print('O preço desse brinquedo é inviável')
elif preco_brinquedo > 100:
    print('Esse brinquedo é muito caro')
else:
    print('Eu compraria esse brinquedo')
\end{verbatim}
\end{listing}

A expressão `if' diz que se o preço do brinquedo for acima de R\$1000, é inviável; se o preço do brinquedo for acima de R\$100, é muito caro.... caso contrário, diz (imprime) ``Eu compraria esse brinquedo''. O Capítulo~\ref{ch:howtoaskaquestion} tem mais informações sobre as expressões `if'.

\subsection*{import}\index{keywords!import}

A palavra-chave \textbf{import} diz ao Python para carregar um módulo para ser usado. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> import sys
\end{verbatim}
\end{listing}

Isso diz ao Python que nós queremos usar o módulo \code{sys}.

\section*{in}\index{keywords!in}

A palavra-chave \textbf{in} é usada em expressões, para saber se um item está em uma coleção de itens. Por exemplo, pode o número 1 ser encontrado na lista (uma coleção) de números:

\begin{listing}
\begin{verbatim}
>>> if 1 in [1, 2, 3, 4]:
...     print('número 1 está na lista')
number is in list
\end{verbatim}
\end{listing}

\noindent
Ou se `alface' pode ser encontrado na lista de compras:

\begin{listing}
\begin{verbatim}
>>> lista_compras = ['ovos', 'leite', 'queijo']
>>> if 'alface' in shopping_list:
...     print('alface está na lista de compras')
... else:
...     print('alface não está na lista de compras')
...
alface não está na lista de compras
\end{verbatim}
\end{listing}

\subsection*{is}\index{keywords!is}

A palavra-chave \textbf{is}, é parecida com o operador de igualdade (==) que é usado para dizer se duas coisas são iguais (por exemplo, 10 == 10 é verdadeiro, 10 ==11 é falso). Porém, existe uma diferença fundamental entre \textbf{is} e ==. Se você está comparando duas coisas, o == retornará verdadeiro (`True') onde o `is' retornaria falso (`False').
\par
Este é um daqueles conceitos extremamente avançados de programação, que tendem a ser bem confusos, então por enquanto vamos ficar apenas com o ==.

\subsection*{lambda}\index{keywords!lambda}

Outra palavra-chave avançada. De fato, `lambda' é tão complicada, até escrever uma explicação sobre ela faria este livro pegar fogo.
\par
\emph{Então é melhor não falarmos sobre isso.}

\subsection*{not}\index{keywords!not}

Se algo é verdadeiro, então a palavra-chave \textbf{not} faz isso ser falso. Por exemplo, se nós criarmos uma variável \code{x} e definirmos seu valor como `True'...

\begin{listing}
\begin{verbatim}
>>> x = True
\end{verbatim}
\end{listing}

...e então imprimirmos o valor de \code{x} usando \textbf{not}, nós teremos:

\begin{listing}
\begin{verbatim}
>>> print(not x)
False
\end{verbatim}
\end{listing}

O que não parece ser muito útil, até que você comece usar o \textbf{not} em uma condição `if'. Por exemplo, se você tem 12 anos e a idade mais importante para você é 12, você pode se referir às demais idades, apenas usando:

\begin{quotation}
``1 não é uma idade importante''
``2 não é uma idade importante''
``3 não é uma idade importante''
``4 não é uma idade importante''
...
...
``50 não é uma idade important''
\end{quotation}

E por assim em diante.
\par\noindent
Nos termos de uma condição `if', nós poderíamos escrever isso assim$\ldots$

\begin{listing}
\begin{verbatim}
if age == 1:
    print("1 não é uma idade importante")
elif age == 2:
    print("2 não é uma idade importante")
elif age == 3:
    print("3 não é uma idade importante")
elif age == 4:
    print("4 não é uma idade importante")
\end{verbatim}
\end{listing}

\noindent
$\ldots$infinitamente. Uma forma mais simples de escrever a mesma condição, seria:

\begin{listing}
\begin{verbatim}
if idade < 10 or idade > 10:
    print("%d não é uma idade importante" % idade)
\end{verbatim}
\end{listing}

\noindent
Mas uma das formas mais simples de escrever essa condição `if', é usando o \textbf{not}:

\begin{listing}
\begin{verbatim}
if not idade == 10:
    print("%d não é uma idade importante" % idade)
\end{verbatim}
\end{listing}

\noindent
Que provavelmente você já deve ter percebido, é o mesmo que dizer: ``se idade não for 10''.

\subsection*{or}\index{keywords!or}

A palavra-chave \textbf{or} é usada para unir duas expressões em uma única condição (assim como o `if'), para dizer que ao menos uma das expressões deve ser verdadeira. Por exemplo:

\begin{listingignore}
\begin{verbatim}
>>> if amigo == 'Rachel' or amigo == 'Rob':
...     print('Os Robinsons')
... elif amigo == 'Bill' or amigo == 'Bob':
...     print('Os Baxters')
\end{verbatim}
\end{listingignore}

Neste caso, a variável \code{amigo} contém `Rachel' ou 'Rob', então imprime `Os Robinsons'. Se a variável \code{amigo} contém `Bill' ou `Bob' então imprime `Os Baxters'.

\subsection*{pass}\index{keywords!pass}

Algumas vezes, você está escrevendo um programa e você quer escrever apenas um pouco, para testar algumas coisas. O problema com isso é que você não pode ter uma condição `if' sem nenhum bloco de código que deverá rodar se a condição for verdadeira. Você também não pode ter um laço `for' sem um bloco de código para ser executado. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> if age > 10:
...     print('older than 10')
\end{verbatim}
\end{listing}

\noindent
The above code will work, but if you type:

\begin{listingignore}
\begin{verbatim}
>>> if age > 10:
...
\end{verbatim}
\end{listingignore}

\noindent
You'll get an error message in the console that looks something like this:

\begin{listingignore}
\begin{verbatim}
  File "<stdin>", line 2
    ^
IndentationError: expected an indented block
\end{verbatim}
\end{listingignore}

This is the error message Python displays, when you should have a block of code after a statement of some kind.
\par
The \textbf{pass} keyword can be used in these cases, so you can write a statement, but not provide the block of code that goes with it.  For example, you might want to write a for-loop, with an if-statement inside it.  Perhaps you haven't decided what to put in the if-statement yet.  Maybe you'll put a print, maybe you'll put a break, maybe something else.  In which case, you can use \textbf{pass} and the code will still work (even if it doesn't do exactly what you want yet).  The code:

\begin{listing}
\begin{verbatim}
>>> for x in range(1,7):
...     print('x is %s' % x)
...     if x == 5:
...         pass
\end{verbatim}
\end{listing}

\noindent
will print out the following:

\begin{listing}
\begin{verbatim}
x is 1
x is 2
x is 3
x is 4
x is 5
x is 6
\end{verbatim}
\end{listing}

\noindent
Later on you can add the code in the block for the if-statement (replacing the \textbf{pass} keyword).

\subsection*{print}\index{keywords!print}

The \textbf{print} keyword, writes something to the Python console; such as a string, a number or a variable:

\begin{listing}
\begin{verbatim}
print('hello there')
print(10)
print(x)
\end{verbatim}
\end{listing}

\subsection*{raise}\index{keywords!raise}

Another advanced keyword.  In this case, \textbf{raise} is used to cause an error to happen---which might seem like a strange thing to do but, in advanced programs, is actually quite useful.

\subsection*{return}\index{keywords!return}

The \textbf{return} keyword is used to return a value from a function.  For example, you might create a function to return the amount of money you've saved:

\begin{listingignore}
\begin{verbatim}
>>> def mymoney():
...     return money_amount
\end{verbatim}
\end{listingignore}

\noindent
When you call this function, the value returned can be assigned to another variable:

\begin{listingignore}
\begin{verbatim}
>>> money = mymoney()
\end{verbatim}
\end{listingignore}

\noindent
or printed:

\begin{listingignore}
\begin{verbatim}
>>> print(mymoney())
\end{verbatim}
\end{listingignore}

\subsection*{try}\index{keywords!try}

The \textbf{try} keyword is the beginning of a block of code that ends with the \textbf{except} and/or \textbf{finally} keywords.  All together, these \textbf{try/except/finally} blocks of code are used to handle errors in a program---for example, to make sure that the program displays a useful message to the user, rather than an ugly Python error.

\subsection*{while}\index{keywords!while}

A bit like a for-loop, \textbf{while} is another way of looping code.  Where a for-loop counts through a range (of numbers), a while loop keeps running while an expression is True.  You have to be rather careful with while loops, because if the expression is always True, the loop will never end (this is called an infinite loop).  For example:

\begin{listingignore}
\begin{verbatim}
>>> x = 1
>>> while x == 1:
...     print('hello')
\end{verbatim}
\end{listingignore}

If you run the above code, it will loop forever.  Well, at least until you either close the Python console, or hit \textbf{CTRL+C} (the control key and the C key together) to interrupt it. However the following code:

\begin{listing}
\begin{verbatim}
>>> x = 1
>>> while x < 10:
...     print('hello')
...     x = x + 1
\end{verbatim}
\end{listing}

Will print `hello' 9 times (each time adding 1 to the variable \code{x}, until \code{x} is no longer less than 10). This is obviously a bit like a for-loop, but does have its uses in certain situations.

\subsection*{with}\index{keywords!with}

\textbf{With} is a very advanced keyword.

\subsection*{yield}\index{keywords!yield}
\textbf{Yield} is another very advanced keyword.

\newpage
