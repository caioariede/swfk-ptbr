% appendixa.tex
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 New Zealand License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

\chapter{Palavras Reservadas em Python}\label{app:pythonkeywords}

Palavras reservadas em Python (na verdade, na maioria das linguagens de programação), são palavras importantes, usadas pela própria linguagem. Se você tentar usar algumas dessas palavras especiais como nomes de variáveis, ou usá-las de forma incorreta, você verá um erro estranho (algumas vezes engraçado, outras confuso), no terminal do Python. Abaixo está cada uma das palavras reservadas em Python e uma breve descrição.

\subsection*{and}\index{keywords!and}

A palavra reservada \textbf{and} é usada para juntar duas expressões em uma só declaração (por exemplo, o `if'), para dizer que essas duas expressões precisam ser verdadeiras. Por exemplo:

\begin{listingignore}
\begin{verbatim}
if idade > 10 and idade < 20
\end{verbatim}
\end{listingignore}

\noindent
Isso significa que a idade deve ser maior que 10 \textbf{e} menor que 20.

\subsection*{as}\index{keywords!as}

A palavra reservada \textbf{as} é usada para dar um outro nome à um módulo importado. Por exemplo, se você tem um módulo com o seguinte nome:

\begin{listingignore}
\begin{verbatim}
eu_sou_um_modulo_do_python_nao_muito_util
\end{verbatim}
\end{listingignore}

\noindent
Seria muito chato ter que digitar o nome do módulo toda vez que você quisesse usá-lo:

\begin{listingignore}
\begin{verbatim}
>>> import eu_sou_um_modulo_do_python_nao_muito_util
>>>
>>> eu_sou_um_modulo_do_python_nao_muito_util.faca_algo()
Fiz algo
>>> eu_sou_um_modulo_do_python_nao_muito_util.faca_outra_coisa()
Fiz outra coisa!
\end{verbatim}
\end{listingignore}

\noindent
Ao invés disso, você pode dar um nome assim que importá-lo e então apenas usar o novo nome (como se fosse um apelido):

\begin{listingignore}
\begin{verbatim}
>>> import eu_sou_um_modulo_do_python_nao_muito_util as poucoutil
>>>
>>> poucoutil.faca_algo_something()
Fiz algo

>>> poucoutil.faca_outra_coisa()
Fiz outra coisa!
\end{verbatim}
\end{listingignore}

\noindent
Apesar de que você não usará a palavra reservada `as' muitas vezes.

\subsection*{assert}\index{keywords!assert}

A palavra reservada \textbf{assert} é uma palavra reservada avançada, que é usada por programadores quando eles querem assegurar que um código seja verdadeiro (ou `True'). É uma outra forma de capturar erros e problemas em um código --- e normalmente usado em programas mais avançados.

\subsection*{break}\index{keywords!break}

A palavra reservada \textbf{break} é usada para parar algum código que está executando. Você deverá usar o `break' dentro de um laço `for':

\begin{listing}
\begin{verbatim}
>>> idade = 25
>>> for x in range(1, 100):
...     print('contando %s' % x)
...     if x == idade:
...         print('fim da contagem')
...         break
\end{verbatim}
\end{listing}

\noindent
Se a variável `idade' for 10, isso é o que será impresso:

\begin{listing}
\begin{verbatim}
contando 1
contando 2
contando 3
contando 4
contando 5
contando 6
contando 7
contando 8
contando 9
contando 10
fim da contagem
\end{verbatim}
\end{listing}

\noindent
Confira o Capítulo~\ref{ch:againandagain} para mais informações sobre os laços `for'.

\subsection*{class}\index{keywords!class}

A palavra reservada \textbf{class} é usada para definir um tipo de objeto. Essa é uma característica presente em muitas linguagens de programação e é muito útil quando estamos desenvolvendo programas mais complicados, mas esse é um assunto um pouco avançado para este livro.

\subsection*{del}\index{keywords!del}

`del' é uma função especial, usada para se livrar de algo. Por exemplo, se você tem uma lista em um diário, contendo os presentes que quer de aniversário, mas mudou de ideia, você poderia riscá-lo da lista, e adicionar um novo:

\begin{center}
\includegraphics*[width=70mm]{eps/list.eps}
\end{center}

\noindent
Se tivéssemos a mesma lista em Python:

\begin{listing}
\begin{verbatim}
>>> eu_quero = ['carrinho de controle remoto', 'bicicleta', 'video-game']
\end{verbatim}
\end{listing}

\noindent
Nós poderíamos remover o video-game, usando o \code{del} e adicionando o novo ítem usando a função `append':

\begin{listing}
\begin{verbatim}
>>> del eu_quero[2]
>>> eu_quero.append('robô-dinossauro')
\end{verbatim}
\end{listing}

\noindent
E então, para ver a nova lista:

\begin{listing}
\begin{verbatim}
>>> print(eu_quero)
['carrinho de controle remoto', 'bicicleta', 'robô-dinossauro']
\end{verbatim}
\end{listing}

\noindent
Veja o Capítulo~\ref{ch:8multipliedby3.57} para mais informações sobre listas.

\subsection*{elif}\index{keywords!elif}

A palavra reservada \textbf{elif} é usada como uma parte da condição `if'. Veja sobre o \textbf{if} mais abaixo...

\subsection*{else}\index{keywords!else}

A palavra reservada \textbf{else} também é usada como uma parte da condição `if'. Veja sobre o \textbf{if} mais abaixo...

\subsection*{except}\index{keywords!except}

Outra palavra reservada para capturar problemas no código. Novamente, o uso desta é para programas mais complicados, muito avançado para este livro.

\subsection*{exec}\index{keywords!exec}

O \textbf{exec} é uma função especial, usada para que uma string seja executada como se fosse um código Python. Por exemplo, você quer criar uma variável com uma string de valor, como abaixo:

\begin{listing}
\begin{verbatim}
>>> minhavar = 'ola!'
\end{verbatim}
\end{listing}

\noindent
E imprimir o seu conteúdo:

\begin{listing}
\begin{verbatim}
>>> print(minhavar)
ola!
\end{verbatim}
\end{listing}

\noindent
Mas você também poderia colocar um código em Python dentro de uma string:

\begin{listing}
\begin{verbatim}
>>> minhavar = 'print("ola!")'
\end{verbatim}
\end{listing}

\noindent
E então você poderia usar o `exec' para tornar essa string em um mini programa Python e executá-lo:

\begin{listing}
\begin{verbatim}
>>> exec(minhavar)
ola!
\end{verbatim}
\end{listing}

Parece uma ideia um pouco estranha e talvez seja algo que não fará sentido até você precisar usar. Como o \code{assert}, essa é uma das palavras-reservadas avançadas que é usada em programas mais sofisticados.

\subsection*{finally}\index{keywords!finally}

Esta é outra palavra reservada avaçada, usada para assegurar que, quando um erro ocorrer, um código em especial será executado (normalmente para limpar a 'bagunça' que um outro código deixou para trás).

\subsection*{for}\index{keywords!for}

A palavra reservada \textbf{for} é usada para criar um laço `for' de alguma forma. Por exemplo:

\begin{listing}
\begin{verbatim}
for x in range(0, 5):
    print('x é %s' % x)
\end{verbatim}
\end{listing}

\noindent
O laço `for' acima, executa um bloco de código (o comando `print') 5 vezes, criando a seguinte saída:

\begin{listing}
\begin{verbatim}
x é 0
x é 1
x é 2
x é 3
x é 4
\end{verbatim}
\end{listing}

\subsection*{from}\index{keywords!from}

Enquanto importando um módulo, você pode querer importar apenas uma parte que você precisa, usando a palavra reservada \textbf{from}. Por exemplo, o módulo `turtle' tem uma função chamada \code{Pen()} que é usada para criar um objeto do tipo `Pen' (basicamente uma tela onde a tartaruga se moverá) --- você pode importar o módulo inteiro e então usar a função \code{Pen}, como abaixo:

\begin{listingignore}
\begin{verbatim}
>>> import turtle
>>> t = turtle.Pen()
\end{verbatim}
\end{listingignore}

Ou, você pode importar apenas a função \code{Pen} e então usá-la diretamente (sem precisar referenciar o módulo `turtle' por completo):

\begin{listingignore}
\begin{verbatim}
>>> from turtle import Pen
>>> t = Pen()
\end{verbatim}
\end{listingignore}

E é claro que isso significa que você não poderá usar outras partes do módulo que você não importou. Por exemplo, o módulo `time' tem uma função chamada `localtime` e outra `gmtime'. Se nós importarmos o `localtime' e então tentarmos usar a `gmtime', teremos um erro:

\begin{listingignore}
\begin{verbatim}
>>> from time import localtime
>>> print(localtime())
(2007, 1, 30, 20, 53, 42, 1, 30, 0)
\end{verbatim}
\end{listingignore}

\noindent
Isso funciona, mas isso:

\begin{listing}
\begin{verbatim}
>>> print(gmtime())
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'gmtime' is not defined
\end{verbatim}
\end{listing}

A mensagem ```gmtime' is not defined'' indica que o Python não sabe da função \code{gmtime}$\ldots$ ainda. Se houverem um monte de funções em um módulo que você quer usar e você não quer referenciar o nome do módulo toda vez que usá-las (ex. \code{time.localtime}, ou \code{time.outra\_coisa}), você pode importar tudo do módulo, de uma só vez, usando o asterísco (*):

\begin{listingignore}
\begin{verbatim}
>>> from time import *
>>> print(localtime())
(2007, 1, 30, 20, 57, 7, 1, 30, 0)
>>> print(gmtime())
(2007, 1, 30, 13, 57, 9, 1, 30, 0)
\end{verbatim}
\end{listingignore}

Neste caso, nós importamos tudo do módulo `time' e podemos referenciar as funções individualmente pelo nome.

\subsection*{global}\index{keywords!global}

No Capítulo~\ref{ch:sortoflikerecycling}, nós falamos sobre \emph{escopo}. Escopo é a `visibilidade' de uma variável. Se a variável é definida fora de uma função, normalmente ela pode ser vista dentro da função. Se definida dentro de uma função, normalmente ela não pode ser vista \textbf{de fora} dessa função.
\par
A palavra reservada \code{global} é uma exceção à essa regra. Uma variável que é definida como global, pode ser vista de qualquer lugar. A definição da palavra `global' é `universal', então você pode pensar no terminal do Python como sendo um universo. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> def teste():
...     global a
...     a = 1
...     b = 2
\end{verbatim}
\end{listing}

O que você acha que acontece quando você chamar \code{print(a)} e então \code{print(b)} depois de executar a função teste? O primeiro irá funcionar, o segundo então causará um erro:

\begin{listing}
\begin{verbatim}
>>> teste()
>>> print(a)
1
>>> print(b)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'b' is not defined
\end{verbatim}
\end{listing}

A variável \code{a} é global agora (visível por todo mundo), mas \code{b} ainda é uma variável visível apenas dentro da função. Observe que você deve chamar \code{global} antes de salvar ou usar a sua variável global.

\subsection*{if}\index{keywords!if}

Uma expressão tomando uma decisão sobre algo --- que em algumas vezes é usado com algumas palavras reservadas adicionais como \code{else} (senão) e o \code{elif} (else if / senão se). Uma expressão `if' é uma forma de dizer, ``se algo for verdade, então faça uma ação''. Por exemplo:

\begin{listing}
\begin{verbatim}
if preco_brinquedo > 1000:
    print('O preço desse brinquedo é inviável')
elif preco_brinquedo > 100:
    print('Esse brinquedo é muito caro')
else:
    print('Eu compraria esse brinquedo')
\end{verbatim}
\end{listing}

A expressão `if' diz que se o preço do brinquedo for acima de R\$1000, é inviável; se o preço do brinquedo for acima de R\$100, é muito caro.... caso contrário, diz (imprime) ``Eu compraria esse brinquedo''. O Capítulo~\ref{ch:howtoaskaquestion} tem mais informações sobre as expressões `if'.

\subsection*{import}\index{keywords!import}

A palavra reservada \textbf{import} diz ao Python para carregar um módulo para ser usado. Por exemplo:

\begin{listing}
\begin{verbatim}
>>> import sys
\end{verbatim}
\end{listing}

Isso diz ao Python que nós queremos usar o módulo \code{sys}.

\section*{in}\index{keywords!in}

A palavra reservada \textbf{in} é usada em expressões, para saber se um item está em uma coleção de itens. Por exemplo, pode o número 1 ser encontrado na lista (uma coleção) de números:

\begin{listing}
\begin{verbatim}
>>> if 1 in [1, 2, 3, 4]:
...     print('número 1 está na lista')
number is in list
\end{verbatim}
\end{listing}

\noindent
Ou se `alface' pode ser encontrado na lista de compras:

\begin{listing}
\begin{verbatim}
>>> lista_compras = ['ovos', 'leite', 'queijo']
>>> if 'alface' in shopping_list:
...     print('alface está na lista de compras')
... else:
...     print('alface não está na lista de compras')
...
alface não está na lista de compras
\end{verbatim}
\end{listing}

\subsection*{is}\index{keywords!is}

The keyword \textbf{is}, is sort of like the equals operator (==) which is used to tell if two things are equal (for example 10 == 10 is true, 10 == 11 is false).  However, there is a fundamental difference between \textbf{is} and ==. If you are comparing two things, == may return true, where is may not (even if you think the things are the same). 
\par
This is one of those extremely advanced programming concepts, that tends to be enormously confusing, so for the moment just stick with using ==.

\subsection*{lambda}\index{keywords!lambda}

Another advanced keyword. In fact lambda is so complicated, even to write an explanation about it would cause this book to burst into flames.
\par
\emph{So best not to talk about it.}

\subsection*{not}\index{keywords!not}

If something is true, the \textbf{not} keyword makes it false.  For example, if we create a variable \code{x} and set it to the value True...

\begin{listing}
\begin{verbatim}
>>> x = True
\end{verbatim}
\end{listing}

...and then print the value of x using \textbf{not}, we get:

\begin{listing}
\begin{verbatim}
>>> print(not x)
False
\end{verbatim}
\end{listing}

Which doesn't seem very useful, until you start using \textbf{not} in if-statements.  For example, if you are 12 years old, and the most important age for you is 12, you don't particular want to refer to all other years by saying:

\begin{quotation}
``1 is not an important age''
``2 is not an important age''
``3 is not an important age''
``4 is not an important age''
...
...
``50 is not an important age''
\end{quotation}

And so on.
\par\noindent
In terms of an if-statement, we could write that as$\ldots$

\begin{listing}
\begin{verbatim}
if age == 1:
    print("1 is not an important age")
elif age == 2:
    print("2 is not an important age")
elif age == 3:
    print("3 is not an important age")
elif age == 4:
    print("4 is not an important age")
\end{verbatim}
\end{listing}

\noindent
$\ldots$continuing on forever. A simpler way to write the statement would be:

\begin{listing}
\begin{verbatim}
if age < 10 or age > 10:
    print("%s is not an important age" % age)
\end{verbatim}
\end{listing}

\noindent
But one of the most simple ways to write that if-statement is by using \textbf{not}:

\begin{listing}
\begin{verbatim}
if not age == 10:
    print("%s is not an important age" % age)
\end{verbatim}
\end{listing}

\noindent
Which, you've probably already realised, is just another way of saying, ``if age is not 10''.

\subsection*{or}\index{keywords!or}

The \textbf{or} keyword is used to join two expressions together in a statement (such as an if-statement), to say that at least one of the expressions should be true.  For example:

\begin{listingignore}
\begin{verbatim}
>>> if friend == 'Rachel' or friend == 'Rob':
...     print('The Robinsons')
... elif friend == 'Bill' or friend == 'Bob':
...     print('The Baxters')
\end{verbatim}
\end{listingignore}

In this case, if the variable \code{friend} contains `Rachel' or `Rob' then it prints `The Robinsons'.  If the variable friend contains `Bill' or `Bob' then it prints `The Baxters'.

\subsection*{pass}\index{keywords!pass}

Sometimes when you're writing a program you only want to write bits of it, to try things out.  The problem with this is that you can't have an if-statement without the block of code that should be run if the expression in the if-statement is true. You also can't have a for-loop without the block of code that should be run in the loop. For example:

\begin{listing}
\begin{verbatim}
>>> if age > 10:
...     print('older than 10')
\end{verbatim}
\end{listing}

\noindent
The above code will work, but if you type:

\begin{listingignore}
\begin{verbatim}
>>> if age > 10:
...
\end{verbatim}
\end{listingignore}

\noindent
You'll get an error message in the console that looks something like this:

\begin{listingignore}
\begin{verbatim}
  File "<stdin>", line 2
    ^
IndentationError: expected an indented block
\end{verbatim}
\end{listingignore}

This is the error message Python displays, when you should have a block of code after a statement of some kind.
\par
The \textbf{pass} keyword can be used in these cases, so you can write a statement, but not provide the block of code that goes with it.  For example, you might want to write a for-loop, with an if-statement inside it.  Perhaps you haven't decided what to put in the if-statement yet.  Maybe you'll put a print, maybe you'll put a break, maybe something else.  In which case, you can use \textbf{pass} and the code will still work (even if it doesn't do exactly what you want yet).  The code:

\begin{listing}
\begin{verbatim}
>>> for x in range(1,7):
...     print('x is %s' % x)
...     if x == 5:
...         pass
\end{verbatim}
\end{listing}

\noindent
will print out the following:

\begin{listing}
\begin{verbatim}
x is 1
x is 2
x is 3
x is 4
x is 5
x is 6
\end{verbatim}
\end{listing}

\noindent
Later on you can add the code in the block for the if-statement (replacing the \textbf{pass} keyword).

\subsection*{print}\index{keywords!print}

The \textbf{print} keyword, writes something to the Python console; such as a string, a number or a variable:

\begin{listing}
\begin{verbatim}
print('hello there')
print(10)
print(x)
\end{verbatim}
\end{listing}

\subsection*{raise}\index{keywords!raise}

Another advanced keyword.  In this case, \textbf{raise} is used to cause an error to happen---which might seem like a strange thing to do but, in advanced programs, is actually quite useful.

\subsection*{return}\index{keywords!return}

The \textbf{return} keyword is used to return a value from a function.  For example, you might create a function to return the amount of money you've saved:

\begin{listingignore}
\begin{verbatim}
>>> def mymoney():
...     return money_amount
\end{verbatim}
\end{listingignore}

\noindent
When you call this function, the value returned can be assigned to another variable:

\begin{listingignore}
\begin{verbatim}
>>> money = mymoney()
\end{verbatim}
\end{listingignore}

\noindent
or printed:

\begin{listingignore}
\begin{verbatim}
>>> print(mymoney())
\end{verbatim}
\end{listingignore}

\subsection*{try}\index{keywords!try}

The \textbf{try} keyword is the beginning of a block of code that ends with the \textbf{except} and/or \textbf{finally} keywords.  All together, these \textbf{try/except/finally} blocks of code are used to handle errors in a program---for example, to make sure that the program displays a useful message to the user, rather than an ugly Python error.

\subsection*{while}\index{keywords!while}

A bit like a for-loop, \textbf{while} is another way of looping code.  Where a for-loop counts through a range (of numbers), a while loop keeps running while an expression is True.  You have to be rather careful with while loops, because if the expression is always True, the loop will never end (this is called an infinite loop).  For example:

\begin{listingignore}
\begin{verbatim}
>>> x = 1
>>> while x == 1:
...     print('hello')
\end{verbatim}
\end{listingignore}

If you run the above code, it will loop forever.  Well, at least until you either close the Python console, or hit \textbf{CTRL+C} (the control key and the C key together) to interrupt it. However the following code:

\begin{listing}
\begin{verbatim}
>>> x = 1
>>> while x < 10:
...     print('hello')
...     x = x + 1
\end{verbatim}
\end{listing}

Will print `hello' 9 times (each time adding 1 to the variable \code{x}, until \code{x} is no longer less than 10). This is obviously a bit like a for-loop, but does have its uses in certain situations.

\subsection*{with}\index{keywords!with}

\textbf{With} is a very advanced keyword.

\subsection*{yield}\index{keywords!yield}
\textbf{Yield} is another very advanced keyword.

\newpage
